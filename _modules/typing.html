<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><link rel="index" title="Index" href="../genindex.html"><link rel="search" title="Search" href="../search.html">

    <!-- Generated with Sphinx 8.2.3 and Furo 2025.09.25 -->
        <title>typing - QCoDeS 0.55.0.dev15 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #eeffcc;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">QCoDeS 0.55.0.dev15 documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  <span class="sidebar-brand-text">QCoDeS 0.55.0.dev15 documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../start/index.html">Getting Started</a><input aria-label="Toggle navigation of Getting Started" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="simple">
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../examples/basic_examples/15_minutes_to_QCoDeS.html">15 minutes to QCoDeS</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../examples/index.html">Examples of using QCoDeS</a><input aria-label="Toggle navigation of Examples of using QCoDeS" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../examples/basic_examples/index.html">Basic examples</a><input aria-label="Toggle navigation of Basic examples" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/basic_examples/15_minutes_to_QCoDeS.html">15 minutes to QCoDeS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/basic_examples/Configuring_QCoDeS.html">QCoDeS config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/basic_examples/Station.html">Station</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../examples/Parameters/index.html">Parameters</a><input aria-label="Toggle navigation of Parameters" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Complex_Parameters.html">Complex Numbers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Legacy_Parameters.html">Legacy parameter examples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/MultiParameter.html">MultiParameter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Parameter-With-Setpoints-defined-on-a-different-instrument.html">ParameterWithSetpoints with setpoints defined on another instrument.</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Parameter_defined_InterDependencies.html">Parameter-defined InterDependencies</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Parameter_defined_InterDependencies.html#ControllingParameter-Example">ControllingParameter Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Parameters.html">Parameters in QCoDeS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Scaled_Parameter.html">ScaledParameter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/Parameters/Simple-Example-of-ParameterWithSetpoints.html">Simple Example of ParameterWithSetpoints</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../examples/DataSet/index.html">DataSet</a><input aria-label="Toggle navigation of DataSet" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Accessing-data-in-DataSet.html">Accessing data in a DataSet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Benchmarking.html">Dataset Benchmarking</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/DataSet-class-walkthrough.html">DataSet class walkthrough</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Database.html">Databases</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Datasaver_Builder.html">Using <code class="docutils literal notranslate"><span class="pre">datasaver_builder</span></code> and <code class="docutils literal notranslate"><span class="pre">dond_into</span></code> to streamline measurements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Dataset_Performance.html">DataSet Performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Exporting-data-to-other-file-formats.html">Exporting QCoDes Datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Extracting-runs-from-one-DB-file-to-another.html">Extracting runs from one DB file to another</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/InMemoryDataSet.html">In memory dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Linking%20to%20parent%20datasets.html">Linking to parent datasets</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Measuring%20X%20as%20a%20function%20of%20time.html">Measuring X as a function of time</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Offline%20Plotting%20Tutorial.html">Offline Plotting Tutorial</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Offline%20plotting%20with%20categorical%20data.html">Offline plotting with categorical data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Offline%20plotting%20with%20complex%20data.html">Offline plotting with complex data</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Paramtypes%20explained.html">Paramtypes explained</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Pedestrian%20example%20of%20subscribing%20to%20a%20DataSet.html">Pedestrian example of subscribing to a DataSet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Performing-measurements-using-qcodes-parameters-and-dataset.html">Performing measurements using QCoDeS parameters and DataSet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Saving_data_in_the_background.html">Saving data in the background</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/The-Experiment-Container.html">The Experiment Container</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Threaded%20data%20acquisition.html">Threaded data acquisition</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Using_doNd_functions_in_comparison_to_Measurement_context_manager_for_performing_measurements.html">Using doNd functions in comparison to Measurement context manager for performing measurements</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Using_register_name.html">Using the <code class="docutils literal notranslate"><span class="pre">register_name</span></code> kwarg to select how a parameter is saved to a dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Working%20with%20snapshots.html">Working with snapshots</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Working-With-Pandas-and-XArray.html">Working with Pandas and XArray</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/import-data-from-legacy-dat-files.html">Importing data from legacy .dat files</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/subscriber%20json%20exporter.html">Subscriber with JSON export</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Real_instruments/Example%20Measurements%20with%20Real%20Instruments.html">Example Measurements with Real Instruments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Cache/read_data_from_cache.html">Read data from cache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/DataSet/Cache/write_for_caching.html">Write data to cache</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../examples/plotting/index.html">Plotting</a><input aria-label="Toggle navigation of Plotting" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/plotting/How-to-use-Plottr-with-QCoDeS-for-live-plotting.html">How to use Plottr with QCoDeS for live plotting?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/plotting/auto_color_scale.html">Auto Color Scale</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../examples/driver_examples/index.html">Drivers</a><input aria-label="Toggle navigation of Drivers" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20Example%20with%20Keysight%20E4980A%20LCR%20meter.html">QCoDeS Example with Keysight E4980A LCR meter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20Example%20with%20Yokogawa%20GS200%20and%20Keithley%207510.html">QCoDeS Example with Yokogawa GS200 and Keithley 7510 Multimeter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20example%20with%20Aim%20TTi%20PL601-P.html">QCoDeS example with Aim TTi PL601-P</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20example%20with%20CopperMountain_M5065.html">Example with Copper Mountain Model M5065 Vector Network Analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20example%20with%20DelegateInstrument.html">Qcodes example with DelegateInstrument driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20example%20with%20Galil%20DMC4133%20Controller.html">QCoDeS example with Galil DMC4133 Controller</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20example%20with%20InstrumentGroup%20and%20DelegateInstrument.html">Qcodes example with InstrumentGroup driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCoDeS%20example%20with%20Keithley%203706A%20System%20Switch.html">QCoDeS example with Keithley 3706A System Switch</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCodes%20example%20with%20Keithley%20S46.html">QCoDeS Example with Tektronix Keithley S46</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCodes%20example%20with%20Rigol%20DG1062.html">QCoDeS Example with the Rigol DG 1062 Instrument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/QCodes%20example%20with%20Tektronix%20DPO%2072004C.html">QCoDeS example with Textronix DPO 7200xx scopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20AMI430.html">QCoDeS Example with AMI430</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Agilent%2034400A.html">QCoDeS Example with Agilent 34400A</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Alazar%20ATS9360.html">QCoDeS Example with Alazar ATS 9360</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Basel%20SP983c%20Preamp.html">Qcodes example with Basel SP983c Preamp and its Remote SP983a</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Cryomagnetics%20TM-620.html">Cryomagnetics TM-620 QCoDeS Driver Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Cryomagnetics4G.html">Cryomagnetics 4G QCoDeS Driver Example</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20DynaCool%20PPMS.html">QCoDeS Example with DynaCool PPMS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20HP8753D.html">QCoDeS Example with HP8753D</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Ithaco.html">QCoDeS Example with Itacho</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keithley%202600.html">QCoDeS Example with with Keithley 2600 series</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keithley%207510.html">QCoDeS Example with Tektronix Keithley 7510 Multimeter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%2033500B.html">QCoDeS Example with Keysight 33500B</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%20344xxA.html">QCoDeS Example with Keysight 344xxA</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%2034980A%20Switch%20Mainframe%20and%20Modules.html">QCoDeS Example with Keysight 34980A Multifunction Switch / Measure Mainframe and Modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%20B1500%20Parameter%20Analyzer.html">Qcodes example with Keysight B1500 Semiconductor Parameter Analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%20B2200%20Series%20Femto%20Leakage%20Switch%20Matrix.html">QCoDeS Example with Keysight B2200 Series Femto Leakage Switch Matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%20Infiniium%20Oscilloscope.html">QCoDeS Example with Keysight Infiniium Oscilloscopes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%20N9030B.html">Qcodes example with Keysight N9030B</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Keysight%20Network%20Analyzer.html">QCoDeS Example with Keysight Network Analyzers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Lakeshore%20325.html">QCoDeS Example with Lakeshore 325</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Lakeshore%20336%20or%20372%20-%20Bluefors%20T%20control.html">QCoDeS Example with the Lakeshore Model 372 to Control the Temperature of the Bluefors Fridge</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Minicircuits%20Switch%20boxes%20%28USB-XSPDT%29.html">QCoDeS Example with Minicircuits Switch Boxes Controlled via USB</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Oxford%20Mercury%20iPS.html">QCoDeS Example with Mercury iPS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Oxford%20Triton.html">QCoDeS Example with Oxford Triton</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20QDev_QDac.html">QCoDeS Example with QDac_channels</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Rigol%20DP832.html">QCoDeS Example with Rigol DP832 Power Supply</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Rigol%20DS1074Z.html">QCoDeS Example with the Rigol DS 1074 Z oscilloscope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Rohde%20Schwarz%20RTO%201000%20series%20Oscilloscope.html">QCoDeS Example with Rohde Schwarz RTO 1000 Series Oscilloscope</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Rohde%20Schwarz%20SGS100A.html">QCoDeS Example with Rohde Schwarz SGS100A RF source</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Rohde%20Schwarz%20ZNB.html">QCoDeS Example with Rohde Schwarz ZNB20/8</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Stahl.html">QCoDeS Example with the Stahl Bias Sources</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Stanford%20SR830.html">QCoDeS Example with Stanford SR830</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Stanford%20SR86x%20with%20buffered%20readout.html">QCoDeS Example with Standford Research SR86x Lock-in Amplifier with Buffered Readout</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Tektronix%20AWG5014C.html">QCoDeS Example with Tektronix AWG5014</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Tektronix%20AWG70002A.html">QCoDeS Example with Tektronix AWG70002A</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Tektronix%20TPS2012.html">QCoDeS Example with Tektronix TPS2012</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20Yokogawa%20GS2xx.html">QCoDeS Example with Yokogawa GS200/GS210</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%20example%20with%20keithley%202450.html">QCoDeS Example with Tektronix Keithley 2450 Source Meter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes%2Bbroadbean%20example%20with%20Tektronix%20AWG5208.html">QCoDeS+Broadbean Example with Tektronix AWG5208</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes-example-with-Signal-Hound-USB-SA124B.html">QCoDeS Example with Signal Hound USB-SA124B</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/driver_examples/Qcodes-example-with-Signal-Hound-USB-SA124B-ParameterWithSetpoints.html">QCoDeS Example with Signal Hound USB-SA124B ParameterWithSetpoints</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../examples/writing_drivers/index.html">Writing Drivers</a><input aria-label="Toggle navigation of Writing Drivers" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/writing_drivers/A-ParameterWithSetpoints-Example-with-Dual-Setpoints.html">A ParameterWithSetpoints Example with Dual Setpoints</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/writing_drivers/Creating-Instrument-Drivers.html">Creating QCoDeS instrument drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/writing_drivers/Creating-Simulated-PyVISA-Instruments.html">Creating Simulated PyVISA Instruments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/writing_drivers/Instruments.html">Instrument</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/writing_drivers/abstract_instruments.html">Abstract Instruments and parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/writing_drivers/abstract_instruments.html#Working-subclass">Working subclass</a></li>
</ul>
</li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../examples/logging/index.html">Logging</a><input aria-label="Toggle navigation of Logging" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../examples/logging/logfile_parsing.html">Logfile parsing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../examples/logging/logging_example.html">Logging</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../community/index.html">Community Guide</a><input aria-label="Toggle navigation of Community Guide" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../community/install.html">Source Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="../community/contributing.html">Contributing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../community/related_projects.html">Related Projects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../community/objects.html">Object Hierarchy</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../dataset/index.html">DataSet</a><input aria-label="Toggle navigation of DataSet" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../dataset/introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dataset/spec.html">DataSet Specification</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dataset/dataset_design.html">Dataset Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dataset/interdependentparams.html">Interdependent Parameters</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api/index.html">QCoDes API documentation</a><input aria-label="Toggle navigation of QCoDes API documentation" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api/calibrations/index.html">qcodes.calibrations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/configuration/index.html">qcodes.configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/dataset/index.html">qcodes.dataset</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/extensions/index.html">qcodes.extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/instrument/index.html">qcodes.instrument</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/interactive_widget.html">qcodes.interactive_widget</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/logger/index.html">qcodes.logger</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/math_utils/index.html">qcodes.math_utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/metadatable/index.html">qcodes.metadatable</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/monitor/index.html">qcodes.monitor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/parameters/index.html">qcodes.parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/plotting/index.html">qcodes.plotting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/station.html">qcodes.station</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/utils/index.html">qcodes.utils</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api/validators/index.html">qcodes.validators</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../drivers_api/index.html">Instrument Drivers</a><input aria-label="Toggle navigation of Instrument Drivers" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Agilent.html">Agilent Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/AimTTi.html">AimTTi Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/AlazarTech.html">Alazar Tech Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/American_magnetics.html">American Magnetics Inc Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Basel.html">Basel Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/CryoMagnetics.html">Cryomagnetics Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Galil.html">Galil Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/HP.html">Hewlett Packard Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Harvard.html">Harvard Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Ithaco.html">Ithaco Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Keithley.html">Keithley Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Keysight.html">Keysight Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Lakeshore.html">Lakeshore Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Minicircuits.html">MiniCircuits Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Oxford.html">Oxford Instruments Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/QDev.html">QDev Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/QuantumDesign.html">Quantum Design Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Rigol.html">Rigol Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/RohdeSchwarz.html">Rohde &amp; Schwarz Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/SRS.html">Stanford Research Systems Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/SignalHound.html">Signal Hound Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Stahl.html">Stahl Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Tektronix.html">Tektronix Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Weinschel.html">Weinschel Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Yokogawa.html">Yokogawa Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../drivers_api/Zhinst.html">Zurich Instruments Drivers</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../changes/index.html">Changelogs</a><input aria-label="Toggle navigation of Changelogs" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../changes/unreleased.html">Unreleased</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.54.1.html">0.54.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.54.0.html">0.54.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.53.0.html">0.53.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.52.0.html">0.52.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.51.0.html">0.51.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.50.1.html">0.50.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.50.0.html">0.50.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.49.0.html">0.49.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.48.0.html">0.48.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.47.0.html">0.47.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.46.0.html">0.46.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.45.0.html">0.45.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.44.1.html">0.44.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.44.0.html">0.44.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.43.0.html">0.43.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.42.1.html">0.42.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.42.0.html">0.42.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.41.1.html">0.41.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.41.0.html">0.41.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.40.0.html">0.40.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.39.1.html">0.39.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.39.0.html">0.39.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.38.1.html">0.38.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.38.0.html">0.38.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.37.0.html">0.37.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.36.1.html">0.36.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.36.0.html">0.36.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.35.2.html">0.35.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.35.1.html">0.35.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.35.0.html">0.35.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.35.0b1.html">0.35.0b1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.34.1.html">0.34.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.34.0.html">0.34.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.33.0.html">0.33.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.32.0.html">0.32.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.31.0.html">0.31.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.30.1.html">0.30.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.30.0.html">0.30.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.29.1.html">0.29.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.29.0.html">0.29.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.28.0.html">0.28.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.27.0.html">0.27.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.26.0.html">0.26.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.25.0.html">0.25.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.24.0.html">0.24.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.23.0.html">0.23.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.22.0.html">0.22.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.21.0.html">0.21.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.20.1.html">0.20.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.20.0.html">0.20.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.19.2.html">0.19.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.19.1.html">0.19.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.19.0.html">0.19.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.18.0.html">0.18.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.17.0.html">0.17.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.16.0.html">0.16.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.15.0.html">0.15.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.15.0a1.html">0.15.0a1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.14.0.html">0.14.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.13.0.html">0.13.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.12.1.html">0.12.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.12.0.html">0.12.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.11.0.html">0.11.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.10.0.html">0.10.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.9.0.html">0.9.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.8.1.html">0.8.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.8.0.html">0.8.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.7.0.html">0.7.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.6.0.html">0.6.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.5.2.html">0.5.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.5.1.html">0.5.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.5.0.html">0.5.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.4.0.html">0.4.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.3.0.html">0.3.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.2.1.html">0.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.2.0.html">0.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.11.html">0.1.11</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.10.html">0.1.10</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.9.html">0.1.9</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.7.html">0.1.7</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.6.html">0.1.6</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.5.html">0.1.5</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.4.html">0.1.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.3.html">0.1.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.2.html">0.1.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../changes/0.1.0.html">0.1.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../help.html">Get Help</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <h1>Source code for typing</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The typing module: Support for gradual typing as defined by PEP 484 and subsequent PEPs.</span>

<span class="sd">Among other things, the module includes the following:</span>
<span class="sd">* Generic, Protocol, and internal machinery to support generic aliases.</span>
<span class="sd">  All subscripted types like X[int], Union[int, str] are generic aliases.</span>
<span class="sd">* Various &quot;special forms&quot; that have unique meanings in type annotations:</span>
<span class="sd">  NoReturn, Never, ClassVar, Self, Concatenate, Unpack, and others.</span>
<span class="sd">* Classes whose instances can be type arguments to generic classes and functions:</span>
<span class="sd">  TypeVar, ParamSpec, TypeVarTuple.</span>
<span class="sd">* Public helper functions: get_type_hints, overload, cast, final, and others.</span>
<span class="sd">* Several protocols to support duck-typing:</span>
<span class="sd">  SupportsFloat, SupportsIndex, SupportsAbs, and others.</span>
<span class="sd">* Special types: NewType, NamedTuple, TypedDict.</span>
<span class="sd">* Deprecated wrapper submodules for re and io related types.</span>
<span class="sd">* Deprecated aliases for builtin types and collections.abc ABCs.</span>

<span class="sd">Any name not present in __all__ is an implementation detail</span>
<span class="sd">that may be changed without notice. Use at your own risk!</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">abstractmethod</span><span class="p">,</span> <span class="n">ABCMeta</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections.abc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">contextlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">stdlib_re</span>  <span class="c1"># Avoid confusion with the re we export.</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">types</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">WrapperDescriptorType</span><span class="p">,</span> <span class="n">MethodWrapperType</span><span class="p">,</span> <span class="n">MethodDescriptorType</span><span class="p">,</span> <span class="n">GenericAlias</span>


<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">_typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">_idfunc</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_idfunc</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="c1"># Please keep __all__ alphabetized within each category.</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># Super-special typing primitives.</span>
    <span class="s1">&#39;Annotated&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Any&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Callable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ClassVar&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Concatenate&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Final&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ForwardRef&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Generic&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Literal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Optional&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ParamSpec&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Protocol&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Tuple&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Type&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TypeVar&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TypeVarTuple&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Union&#39;</span><span class="p">,</span>

    <span class="c1"># ABCs (from collections.abc).</span>
    <span class="s1">&#39;AbstractSet&#39;</span><span class="p">,</span>  <span class="c1"># collections.abc.Set.</span>
    <span class="s1">&#39;ByteString&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Container&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ContextManager&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Hashable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ItemsView&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Iterable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Iterator&#39;</span><span class="p">,</span>
    <span class="s1">&#39;KeysView&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Mapping&#39;</span><span class="p">,</span>
    <span class="s1">&#39;MappingView&#39;</span><span class="p">,</span>
    <span class="s1">&#39;MutableMapping&#39;</span><span class="p">,</span>
    <span class="s1">&#39;MutableSequence&#39;</span><span class="p">,</span>
    <span class="s1">&#39;MutableSet&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Sequence&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Sized&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ValuesView&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Awaitable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AsyncIterator&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AsyncIterable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Coroutine&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Collection&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AsyncGenerator&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AsyncContextManager&#39;</span><span class="p">,</span>

    <span class="c1"># Structural checks, a.k.a. protocols.</span>
    <span class="s1">&#39;Reversible&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SupportsAbs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SupportsBytes&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SupportsComplex&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SupportsFloat&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SupportsIndex&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SupportsInt&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SupportsRound&#39;</span><span class="p">,</span>

    <span class="c1"># Concrete collection types.</span>
    <span class="s1">&#39;ChainMap&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Counter&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Deque&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Dict&#39;</span><span class="p">,</span>
    <span class="s1">&#39;DefaultDict&#39;</span><span class="p">,</span>
    <span class="s1">&#39;List&#39;</span><span class="p">,</span>
    <span class="s1">&#39;OrderedDict&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Set&#39;</span><span class="p">,</span>
    <span class="s1">&#39;FrozenSet&#39;</span><span class="p">,</span>
    <span class="s1">&#39;NamedTuple&#39;</span><span class="p">,</span>  <span class="c1"># Not really a type.</span>
    <span class="s1">&#39;TypedDict&#39;</span><span class="p">,</span>  <span class="c1"># Not really a type.</span>
    <span class="s1">&#39;Generator&#39;</span><span class="p">,</span>

    <span class="c1"># Other concrete types.</span>
    <span class="s1">&#39;BinaryIO&#39;</span><span class="p">,</span>
    <span class="s1">&#39;IO&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Match&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Pattern&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TextIO&#39;</span><span class="p">,</span>

    <span class="c1"># One-off things.</span>
    <span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_type&#39;</span><span class="p">,</span>
    <span class="s1">&#39;assert_never&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cast&#39;</span><span class="p">,</span>
    <span class="s1">&#39;clear_overloads&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dataclass_transform&#39;</span><span class="p">,</span>
    <span class="s1">&#39;final&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_args&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_origin&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_overloads&#39;</span><span class="p">,</span>
    <span class="s1">&#39;get_type_hints&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_typeddict&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LiteralString&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Never&#39;</span><span class="p">,</span>
    <span class="s1">&#39;NewType&#39;</span><span class="p">,</span>
    <span class="s1">&#39;no_type_check&#39;</span><span class="p">,</span>
    <span class="s1">&#39;no_type_check_decorator&#39;</span><span class="p">,</span>
    <span class="s1">&#39;NoReturn&#39;</span><span class="p">,</span>
    <span class="s1">&#39;NotRequired&#39;</span><span class="p">,</span>
    <span class="s1">&#39;overload&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ParamSpecArgs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ParamSpecKwargs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Required&#39;</span><span class="p">,</span>
    <span class="s1">&#39;reveal_type&#39;</span><span class="p">,</span>
    <span class="s1">&#39;runtime_checkable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Self&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Text&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TYPE_CHECKING&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TypeAlias&#39;</span><span class="p">,</span>
    <span class="s1">&#39;TypeGuard&#39;</span><span class="p">,</span>
    <span class="s1">&#39;Unpack&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># The pseudo-submodules &#39;re&#39; and &#39;io&#39; are part of the public</span>
<span class="c1"># namespace, but excluded from __all__ because they might stomp on</span>
<span class="c1"># legitimate imports of those modules.</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For converting None to type(None), and strings to ForwardRef.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="n">allow_special_forms</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arg</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check that the argument is a type, and return it (internal helper).</span>

<span class="sd">    As a special case, accept None and return type(None) instead. Also wrap strings</span>
<span class="sd">    into ForwardRef instances. Consider several corner cases, for example plain</span>
<span class="sd">    special forms like Union are not valid, while Union[int, str] is OK, etc.</span>
<span class="sd">    The msg argument is a human-readable error message, e.g.::</span>

<span class="sd">        &quot;Union[arg, ...]: arg should be a type.&quot;</span>

<span class="sd">    We append the repr() of the actual value (truncated to 100 chars).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">invalid_generic_forms</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_special_forms</span><span class="p">:</span>
        <span class="n">invalid_generic_forms</span> <span class="o">+=</span> <span class="p">(</span><span class="n">ClassVar</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">is_argument</span><span class="p">:</span>
            <span class="n">invalid_generic_forms</span> <span class="o">+=</span> <span class="p">(</span><span class="n">Final</span><span class="p">,)</span>

    <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="n">allow_special_forms</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="n">invalid_generic_forms</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Any</span><span class="p">,</span> <span class="n">LiteralString</span><span class="p">,</span> <span class="n">NoReturn</span><span class="p">,</span> <span class="n">Never</span><span class="p">,</span> <span class="n">Self</span><span class="p">,</span> <span class="n">TypeAlias</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span>
    <span class="k">if</span> <span class="n">allow_special_forms</span> <span class="ow">and</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ClassVar</span><span class="p">,</span> <span class="n">Final</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">arg</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_SpecialForm</span><span class="p">)</span> <span class="ow">or</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Plain </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2"> Got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r:</span><span class="s2">.100</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arg</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_param_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arg</span> <span class="ow">is</span> <span class="o">...</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span>
            <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">,</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for munging collections.abc.Callable&#39;s __args__.</span>

<span class="sd">    The canonical representation for a Callable&#39;s __args__ flattens the</span>
<span class="sd">    argument types, see https://github.com/python/cpython/issues/86361.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; import collections.abc</span>
<span class="sd">        &gt;&gt;&gt; P = ParamSpec(&#39;P&#39;)</span>
<span class="sd">        &gt;&gt;&gt; collections.abc.Callable[[int, int], str].__args__ == (int, int, str)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; collections.abc.Callable[P, str].__args__ == (P, str)</span>
<span class="sd">        True</span>

<span class="sd">    As a result, if we need to reconstruct the Callable from its __args__,</span>
<span class="sd">    we need to unflatten it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">typ</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span>
        <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_type_repr</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the repr() of an object, special-casing types (internal helper).</span>

<span class="sd">    If obj is a type, we return a shorter version than the default</span>
<span class="sd">    type.__repr__, based on the module and qualified name, which is</span>
<span class="sd">    typically enough to uniquely identify a type.  For everything</span>
<span class="sd">    else, we fall back on repr(obj).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GenericAlias</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;builtins&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
        <span class="k">return</span><span class="p">(</span><span class="s1">&#39;...&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_collect_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect all type variables and parameter specifications in args</span>
<span class="sd">    in order of first appearance (lexicographic order).</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; P = ParamSpec(&#39;P&#39;)</span>
<span class="sd">        &gt;&gt;&gt; T = TypeVar(&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; _collect_parameters((T, Callable[P, T]))</span>
<span class="sd">        (~T, ~P)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="c1"># We don&#39;t want __parameters__ descriptor of a bare Python class.</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># `t` might be a tuple, when `ParamSpec` is substituted with</span>
            <span class="c1"># `[T, int]`, or `[int, *Ts]`, etc.</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">collected</span> <span class="ow">in</span> <span class="n">_collect_parameters</span><span class="p">([</span><span class="n">x</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">collected</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                        <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collected</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;__typing_subst__&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="p">()):</span>
                <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
                    <span class="n">parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_generic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">elen</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check correct count for parameters of a generic cls (internal helper).</span>

<span class="sd">    This gives a nice error message in case of count mismatch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">elen</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2"> is not a generic class&quot;</span><span class="p">)</span>
    <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">alen</span> <span class="o">!=</span> <span class="n">elen</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too </span><span class="si">{</span><span class="s1">&#39;many&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">alen</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">elen</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;few&#39;</span><span class="si">}</span><span class="s2"> arguments for </span><span class="si">{</span><span class="bp">cls</span><span class="si">}</span><span class="s2">;&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">elen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_unpack_args</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">newargs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">subargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__typing_unpacked_tuple_args__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subargs</span> <span class="ow">and</span> <span class="n">subargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">):</span>
            <span class="n">newargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">newargs</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_deduplicate</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">unhashable_fallback</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="c1"># Weed out strict duplicates, preserving the first of each occurrence.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unhashable_fallback</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="c1"># Happens for cases like `Annotated[dict, {&#39;x&#39;: IntValidator()}]`</span>
        <span class="k">return</span> <span class="n">_deduplicate_unhashable</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_deduplicate_unhashable</span><span class="p">(</span><span class="n">unhashable_params</span><span class="p">):</span>
    <span class="n">new_unhashable</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">unhashable_params</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_unhashable</span><span class="p">:</span>
            <span class="n">new_unhashable</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_unhashable</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_compare_args_orderless</span><span class="p">(</span><span class="n">first_args</span><span class="p">,</span> <span class="n">second_args</span><span class="p">):</span>
    <span class="n">first_unhashable</span> <span class="o">=</span> <span class="n">_deduplicate_unhashable</span><span class="p">(</span><span class="n">first_args</span><span class="p">)</span>
    <span class="n">second_unhashable</span> <span class="o">=</span> <span class="n">_deduplicate_unhashable</span><span class="p">(</span><span class="n">second_args</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">second_unhashable</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">first_unhashable</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_remove_dups_flatten</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for Union creation and substitution.</span>

<span class="sd">    Flatten Unions among parameters, then remove duplicates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Flatten out Union[Union[...], ...].</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="p">(</span><span class="n">_UnionGenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_deduplicate</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">unhashable_fallback</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_flatten_literal_params</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal helper for Literal creation: flatten Literals among parameters.&quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">_LiteralGenericAlias</span><span class="p">):</span>
            <span class="n">params</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>


<span class="n">_cleanups</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_tp_cache</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">typed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal wrapper caching __getitem__ of generic types.</span>

<span class="sd">    For non-hashable arguments, the original function is used as a fallback.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="n">cached</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">lru_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="n">typed</span><span class="p">)(</span><span class="n">func</span><span class="p">)</span>
        <span class="n">_cleanups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cached</span><span class="o">.</span><span class="n">cache_clear</span><span class="p">)</span>

        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cached</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>  <span class="c1"># All real errors (not unhashable args) are raised below.</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inner</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decorator</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_eval_type</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate all forward references in the given type t.</span>

<span class="sd">    For use of globalns and localns see the docstring for get_type_hints().</span>
<span class="sd">    recursive_guard is used to prevent infinite recursion with a recursive</span>
<span class="sd">    ForwardRef.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">_evaluate</span><span class="p">(</span><span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="n">ForwardRef</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span>
                <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span>
            <span class="p">)</span>
            <span class="n">is_unpacked</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__unpacked__</span>
            <span class="k">if</span> <span class="n">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">[(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">[</span><span class="n">args</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">is_unpacked</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">Unpack</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">ev_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_eval_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ev_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">GenericAlias</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">ev_args</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">ev_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">ev_args</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_Final</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to prohibit subclassing.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__weakref__&#39;</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;_root&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot subclass special typing classes&quot;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_Immutable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to indicate that object should not be copied.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_NotIterable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin to prevent iteration, without being compatible with Iterable.</span>

<span class="sd">    That is, we could do::</span>

<span class="sd">        def __iter__(self): raise TypeError()</span>

<span class="sd">    But this would make users of this mixin duck type-compatible with</span>
<span class="sd">    collections.abc.Iterable - isinstance(foo, Iterable) would be True.</span>

<span class="sd">    Luckily, we can instead prevent iteration by setting __iter__ to None, which</span>
<span class="sd">    is treated specially.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="fm">__iter__</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># Internal indicator of special typing constructs.</span>
<span class="c1"># See __doc__ instance attribute for specific docs.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_SpecialForm</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="s1">&#39;_getitem&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">getitem</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span> <span class="o">=</span> <span class="n">getitem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">getitem</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">getitem</span><span class="o">.</span><span class="vm">__doc__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subclass </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot instantiate </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> cannot be used with isinstance()&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> cannot be used with issubclass()&quot;</span><span class="p">)</span>

    <span class="nd">@_tp_cache</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_LiteralSpecialForm</span><span class="p">(</span><span class="n">_SpecialForm</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parameters</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_AnyMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;typing.Any cannot be used with isinstance()&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;typing.Any&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>  <span class="c1"># respect to subclasses</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Any</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_AnyMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type indicating an unconstrained type.</span>

<span class="sd">    - Any is compatible with every type.</span>
<span class="sd">    - Any assumed to have all methods.</span>
<span class="sd">    - All values assumed to be instances of Any.</span>

<span class="sd">    Note that all the above statements are true from the point of view of</span>
<span class="sd">    static type checkers. At runtime, Any should not be used with instance</span>
<span class="sd">    checks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="n">Any</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Any cannot be instantiated&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">NoReturn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type indicating functions that never return.</span>

<span class="sd">    Example::</span>

<span class="sd">        from typing import NoReturn</span>

<span class="sd">        def stop() -&gt; NoReturn:</span>
<span class="sd">            raise Exception(&#39;no way&#39;)</span>

<span class="sd">    NoReturn can also be used as a bottom type, a type that</span>
<span class="sd">    has no values. Starting in Python 3.11, the Never type should</span>
<span class="sd">    be used for this concept instead. Type checkers should treat the two</span>
<span class="sd">    equivalently.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>

<span class="c1"># This is semantically identical to NoReturn, but it is implemented</span>
<span class="c1"># separately so that type checkers can distinguish between the two</span>
<span class="c1"># if they want.</span>
<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Never</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The bottom type, a type that has no members.</span>

<span class="sd">    This can be used to define a function that should never be</span>
<span class="sd">    called, or a function that never returns::</span>

<span class="sd">        from typing import Never</span>

<span class="sd">        def never_call_me(arg: Never) -&gt; None:</span>
<span class="sd">            pass</span>

<span class="sd">        def int_or_str(arg: int | str) -&gt; None:</span>
<span class="sd">            never_call_me(arg)  # type checker error</span>
<span class="sd">            match arg:</span>
<span class="sd">                case int():</span>
<span class="sd">                    print(&quot;It&#39;s an int&quot;)</span>
<span class="sd">                case str():</span>
<span class="sd">                    print(&quot;It&#39;s a str&quot;)</span>
<span class="sd">                case _:</span>
<span class="sd">                    never_call_me(arg)  # OK, arg is of type Never</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Self</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Used to spell the type of &quot;self&quot; in classes.</span>

<span class="sd">    Example::</span>

<span class="sd">        from typing import Self</span>

<span class="sd">        class Foo:</span>
<span class="sd">            def return_self(self) -&gt; Self:</span>
<span class="sd">                ...</span>
<span class="sd">                return self</span>

<span class="sd">    This is especially useful for:</span>
<span class="sd">        - classmethods that are used as alternative constructors</span>
<span class="sd">        - annotating an `__enter__` method which returns self</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">LiteralString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an arbitrary literal string.</span>

<span class="sd">    Example::</span>

<span class="sd">        from typing import LiteralString</span>

<span class="sd">        def run_query(sql: LiteralString) -&gt; None:</span>
<span class="sd">            ...</span>

<span class="sd">        def caller(arbitrary_string: str, literal_string: LiteralString) -&gt; None:</span>
<span class="sd">            run_query(&quot;SELECT * FROM students&quot;)  # OK</span>
<span class="sd">            run_query(literal_string)  # OK</span>
<span class="sd">            run_query(&quot;SELECT * FROM &quot; + literal_string)  # OK</span>
<span class="sd">            run_query(arbitrary_string)  # type checker error</span>
<span class="sd">            run_query(  # type checker error</span>
<span class="sd">                f&quot;SELECT * FROM students WHERE name = {arbitrary_string}&quot;</span>
<span class="sd">            )</span>

<span class="sd">    Only string literals and other LiteralStrings are compatible</span>
<span class="sd">    with LiteralString. This provides a tool to help prevent</span>
<span class="sd">    security issues such as SQL injection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ClassVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special type construct to mark class variables.</span>

<span class="sd">    An annotation wrapped in ClassVar indicates that a given</span>
<span class="sd">    attribute is intended to be used as a class variable and</span>
<span class="sd">    should not be set on instances of that class.</span>

<span class="sd">    Usage::</span>

<span class="sd">        class Starship:</span>
<span class="sd">            stats: ClassVar[dict[str, int]] = {} # class variable</span>
<span class="sd">            damage: int = 10                     # instance variable</span>

<span class="sd">    ClassVar accepts only types and cannot be further subscribed.</span>

<span class="sd">    Note that ClassVar is not a class itself, and should not</span>
<span class="sd">    be used with isinstance() or issubclass().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>

<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Final</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to indicate final names to type checkers.</span>

<span class="sd">    A final name cannot be re-assigned or overridden in a subclass.</span>

<span class="sd">    For example::</span>

<span class="sd">        MAX_SIZE: Final = 9000</span>
<span class="sd">        MAX_SIZE += 1  # Error reported by type checker</span>

<span class="sd">        class Connection:</span>
<span class="sd">            TIMEOUT: Final[int] = 10</span>

<span class="sd">        class FastConnector(Connection):</span>
<span class="sd">            TIMEOUT = 1  # Error reported by type checker</span>

<span class="sd">    There is no runtime checking of these properties.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>

<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Union type; Union[X, Y] means either X or Y.</span>

<span class="sd">    On Python 3.10 and higher, the | operator</span>
<span class="sd">    can also be used to denote unions;</span>
<span class="sd">    X | Y means the same thing to the type checker as Union[X, Y].</span>

<span class="sd">    To define a union, use e.g. Union[int, str]. Details:</span>
<span class="sd">    - The arguments must be types and there must be at least one.</span>
<span class="sd">    - None as an argument is a special case and is replaced by</span>
<span class="sd">      type(None).</span>
<span class="sd">    - Unions of unions are flattened, e.g.::</span>

<span class="sd">        assert Union[Union[int, str], float] == Union[int, str, float]</span>

<span class="sd">    - Unions of a single argument vanish, e.g.::</span>

<span class="sd">        assert Union[int] == int  # The constructor actually returns int</span>

<span class="sd">    - Redundant arguments are skipped, e.g.::</span>

<span class="sd">        assert Union[int, str, int] == Union[int, str]</span>

<span class="sd">    - When comparing unions, the argument order is ignored, e.g.::</span>

<span class="sd">        assert Union[int, str] == Union[str, int]</span>

<span class="sd">    - You cannot subclass or instantiate a union.</span>
<span class="sd">    - You can use Optional[X] as a shorthand for Union[X, None].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">parameters</span> <span class="o">==</span> <span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot take a Union of no types.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Union[arg, ...]: each arg must be a type.&quot;</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">_remove_dups_flatten</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_UnionGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Optional&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_UnionGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>

<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Optional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optional[X] is equivalent to Union[X, None].&quot;&quot;&quot;</span>
    <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> requires a single type.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>

<span class="nd">@_LiteralSpecialForm</span>
<span class="nd">@_tp_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Literal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing form to define literal types (a.k.a. value types).</span>

<span class="sd">    This form can be used to indicate to type checkers that the corresponding</span>
<span class="sd">    variable or function parameter has a value equivalent to the provided</span>
<span class="sd">    literal (or one of several literals)::</span>

<span class="sd">        def validate_simple(data: Any) -&gt; Literal[True]:  # always returns True</span>
<span class="sd">            ...</span>

<span class="sd">        MODE = Literal[&#39;r&#39;, &#39;rb&#39;, &#39;w&#39;, &#39;wb&#39;]</span>
<span class="sd">        def open_helper(file: str, mode: MODE) -&gt; str:</span>
<span class="sd">            ...</span>

<span class="sd">        open_helper(&#39;/some/path&#39;, &#39;r&#39;)  # Passes type check</span>
<span class="sd">        open_helper(&#39;/other/path&#39;, &#39;typo&#39;)  # Error in type checker</span>

<span class="sd">    Literal[...] cannot be subclassed. At runtime, an arbitrary value</span>
<span class="sd">    is allowed as type argument to Literal[...], but type checkers may</span>
<span class="sd">    impose restrictions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># There is no &#39;_type_check&#39; call because arguments to Literal[...] are</span>
    <span class="c1"># values, not types.</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="n">_flatten_literal_params</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">_deduplicate</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">))))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># unhashable parameters</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">_LiteralGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">TypeAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special form for marking type aliases.</span>

<span class="sd">    Use TypeAlias to indicate that an assignment should</span>
<span class="sd">    be recognized as a proper type alias definition by type</span>
<span class="sd">    checkers.</span>

<span class="sd">    For example::</span>

<span class="sd">        Predicate: TypeAlias = Callable[..., bool]</span>

<span class="sd">    It&#39;s invalid when used anywhere except as in the example above.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not subscriptable&quot;</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Concatenate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special form for annotating higher-order functions.</span>

<span class="sd">    ``Concatenate`` can be used in conjunction with ``ParamSpec`` and</span>
<span class="sd">    ``Callable`` to represent a higher-order function which adds, removes or</span>
<span class="sd">    transforms the parameters of a callable.</span>

<span class="sd">    For example::</span>

<span class="sd">        Callable[Concatenate[int, P], int]</span>

<span class="sd">    See PEP 612 for detailed information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">parameters</span> <span class="o">==</span> <span class="p">():</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot take a Concatenate of no types.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">parameters</span><span class="p">,)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">ParamSpec</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;The last parameter to Concatenate should be a &quot;</span>
                        <span class="s2">&quot;ParamSpec variable or ellipsis.&quot;</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Concatenate[arg, ...]: each arg must be a type.&quot;</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">parameters</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                                    <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">TypeGuard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct for marking user-defined type guard functions.</span>

<span class="sd">    ``TypeGuard`` can be used to annotate the return type of a user-defined</span>
<span class="sd">    type guard function.  ``TypeGuard`` only accepts a single type argument.</span>
<span class="sd">    At runtime, functions marked this way should return a boolean.</span>

<span class="sd">    ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static</span>
<span class="sd">    type checkers to determine a more precise type of an expression within a</span>
<span class="sd">    program&#39;s code flow.  Usually type narrowing is done by analyzing</span>
<span class="sd">    conditional code flow and applying the narrowing to a block of code.  The</span>
<span class="sd">    conditional expression here is sometimes referred to as a &quot;type guard&quot;.</span>

<span class="sd">    Sometimes it would be convenient to use a user-defined boolean function</span>
<span class="sd">    as a type guard.  Such a function should use ``TypeGuard[...]`` as its</span>
<span class="sd">    return type to alert static type checkers to this intention.</span>

<span class="sd">    Using  ``-&gt; TypeGuard`` tells the static type checker that for a given</span>
<span class="sd">    function:</span>

<span class="sd">    1. The return value is a boolean.</span>
<span class="sd">    2. If the return value is ``True``, the type of its argument</span>
<span class="sd">       is the type inside ``TypeGuard``.</span>

<span class="sd">       For example::</span>

<span class="sd">           def is_str(val: Union[str, float]):</span>
<span class="sd">               # &quot;isinstance&quot; type guard</span>
<span class="sd">               if isinstance(val, str):</span>
<span class="sd">                   # Type of ``val`` is narrowed to ``str``</span>
<span class="sd">                   ...</span>
<span class="sd">               else:</span>
<span class="sd">                   # Else, type of ``val`` is narrowed to ``float``.</span>
<span class="sd">                   ...</span>

<span class="sd">    Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower</span>
<span class="sd">    form of ``TypeA`` (it can even be a wider form) and this may lead to</span>
<span class="sd">    type-unsafe results.  The main reason is to allow for things like</span>
<span class="sd">    narrowing ``List[object]`` to ``List[str]`` even though the latter is not</span>
<span class="sd">    a subtype of the former, since ``List`` is invariant.  The responsibility of</span>
<span class="sd">    writing type-safe type guards is left to the user.</span>

<span class="sd">    ``TypeGuard`` also works with type variables.  For more information, see</span>
<span class="sd">    PEP 647 (User-Defined Type Guards).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ForwardRef</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal wrapper to hold a forward reference.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;__forward_arg__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_code__&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;__forward_evaluated__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_value__&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;__forward_is_argument__&#39;</span><span class="p">,</span> <span class="s1">&#39;__forward_is_class__&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;__forward_module__&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward reference must be a string -- got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># If we do `def f(*args: *Ts)`, then we&#39;ll have `arg = &#39;*Ts&#39;`.</span>
        <span class="c1"># Unfortunately, this isn&#39;t a valid expression on its own, so we</span>
        <span class="c1"># do the unpacking manually.</span>
        <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">):</span>
            <span class="n">arg_to_compile</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s1">,)[0]&#39;</span>  <span class="c1"># E.g. (*Ts,)[0] or (*tuple[int, int],)[0]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arg_to_compile</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">arg_to_compile</span><span class="p">,</span> <span class="s1">&#39;&lt;string&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;eval&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Forward reference must be an expression -- got </span><span class="si">{</span><span class="n">arg</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_code__</span> <span class="o">=</span> <span class="n">code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_argument__</span> <span class="o">=</span> <span class="n">is_argument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_class__</span> <span class="o">=</span> <span class="n">is_class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="o">=</span> <span class="n">module</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">in</span> <span class="n">recursive_guard</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="ow">or</span> <span class="n">localns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">globalns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">globalns</span> <span class="o">=</span> <span class="n">localns</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">elif</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">globalns</span> <span class="o">=</span> <span class="n">localns</span>
            <span class="k">elif</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">globalns</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="n">globalns</span>
                <span class="p">)</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span>
                <span class="nb">eval</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_code__</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">),</span>
                <span class="s2">&quot;Forward references must evaluate to types.&quot;</span><span class="p">,</span>
                <span class="n">is_argument</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_argument__</span><span class="p">,</span>
                <span class="n">allow_special_forms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_is_class__</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span>
                <span class="n">type_</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">,</span> <span class="n">recursive_guard</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_evaluated__</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_evaluated__</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">and</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__forward_value__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_value__</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_arg__</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">module_repr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">module_repr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;, module=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_module__</span><span class="si">!r}</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;ForwardRef(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__forward_arg__</span><span class="si">!r}{</span><span class="n">module_repr</span><span class="si">}</span><span class="s1">)&#39;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">type</span><span class="p">))</span> <span class="ow">and</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;__typing_is_unpacked_typevartuple__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_typevar_like</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">TypeVar</span><span class="p">,</span> <span class="n">ParamSpec</span><span class="p">))</span> <span class="ow">or</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_PickleUsingNameMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin enabling pickling based on self.__name__.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_BoundVarianceMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mixin giving __init__ bound and variance arguments.</span>

<span class="sd">    This is used by TypeVar and ParamSpec, which both employ the notions of</span>
<span class="sd">    a type &#39;bound&#39; (restricting type arguments to be a subtype of some</span>
<span class="sd">    specified type) and type &#39;variance&#39; (determining subtype relations between</span>
<span class="sd">    generic types).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="n">covariant</span><span class="p">,</span> <span class="n">contravariant</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Used to setup TypeVars and ParamSpec&#39;s bound, covariant and</span>
<span class="sd">        contravariant attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">covariant</span> <span class="ow">and</span> <span class="n">contravariant</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Bivariant types are not supported.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__covariant__</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">covariant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__contravariant__</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">contravariant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bound</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__bound__</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="s2">&quot;Bound must be a type.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__bound__</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__covariant__</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__contravariant__</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;~&#39;</span>
        <span class="k">return</span> <span class="n">prefix</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TypeVar</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_BoundVarianceMixin</span><span class="p">,</span> <span class="n">_PickleUsingNameMixin</span><span class="p">,</span>
              <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Type variable.</span>

<span class="sd">    Usage::</span>

<span class="sd">      T = TypeVar(&#39;T&#39;)  # Can be anything</span>
<span class="sd">      A = TypeVar(&#39;A&#39;, str, bytes)  # Must be str or bytes</span>

<span class="sd">    Type variables exist primarily for the benefit of static type</span>
<span class="sd">    checkers.  They serve as the parameters for generic types as well</span>
<span class="sd">    as for generic function definitions.  See class Generic for more</span>
<span class="sd">    information on generic types.  Generic functions work as follows:</span>

<span class="sd">      def repeat(x: T, n: int) -&gt; List[T]:</span>
<span class="sd">          &#39;&#39;&#39;Return a list containing n references to x.&#39;&#39;&#39;</span>
<span class="sd">          return [x]*n</span>

<span class="sd">      def longest(x: A, y: A) -&gt; A:</span>
<span class="sd">          &#39;&#39;&#39;Return the longest of two strings.&#39;&#39;&#39;</span>
<span class="sd">          return x if len(x) &gt;= len(y) else y</span>

<span class="sd">    The latter example&#39;s signature is essentially the overloading</span>
<span class="sd">    of (str, str) -&gt; str and (bytes, bytes) -&gt; bytes.  Also note</span>
<span class="sd">    that if the arguments are instances of some subclass of str,</span>
<span class="sd">    the return type is still plain str.</span>

<span class="sd">    At runtime, isinstance(x, T) and issubclass(C, T) will raise TypeError.</span>

<span class="sd">    Type variables defined with covariant=True or contravariant=True</span>
<span class="sd">    can be used to declare covariant or contravariant generic types.</span>
<span class="sd">    See PEP 484 for more details. By default generic types are invariant</span>
<span class="sd">    in all type variables.</span>

<span class="sd">    Type variables can be introspected. e.g.:</span>

<span class="sd">      T.__name__ == &#39;T&#39;</span>
<span class="sd">      T.__constraints__ == ()</span>
<span class="sd">      T.__covariant__ == False</span>
<span class="sd">      T.__contravariant__ = False</span>
<span class="sd">      A.__constraints__ == (str, bytes)</span>

<span class="sd">    Note that only type variables defined in global scope can be pickled.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">constraints</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">covariant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">covariant</span><span class="p">,</span> <span class="n">contravariant</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constraints</span> <span class="ow">and</span> <span class="n">bound</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Constraints cannot be combined with bound=...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constraints</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;A single constraint is not allowed&quot;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;TypeVar(name, constraint, ...): constraints must be types.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__constraints__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">constraints</span><span class="p">)</span>
        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters to generic types must be types.&quot;</span>
        <span class="n">arg</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__unpacked__&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2"> is not valid as type argument&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TypeVarTuple</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_PickleUsingNameMixin</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Type variable tuple.</span>

<span class="sd">    Usage:</span>

<span class="sd">      Ts = TypeVarTuple(&#39;Ts&#39;)  # Can be given any name</span>

<span class="sd">    Just as a TypeVar (type variable) is a placeholder for a single type,</span>
<span class="sd">    a TypeVarTuple is a placeholder for an *arbitrary* number of types. For</span>
<span class="sd">    example, if we define a generic class using a TypeVarTuple:</span>

<span class="sd">      class C(Generic[*Ts]): ...</span>

<span class="sd">    Then we can parameterize that class with an arbitrary number of type</span>
<span class="sd">    arguments:</span>

<span class="sd">      C[int]       # Fine</span>
<span class="sd">      C[int, str]  # Also fine</span>
<span class="sd">      C[()]        # Even this is fine</span>

<span class="sd">    For more details, see PEP 646.</span>

<span class="sd">    Note that only TypeVarTuples defined in global scope can be pickled.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Used for pickling.</span>
        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">Unpack</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Substitution of bare TypeVarTuple is not supported&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_prepare_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">__parameters__</span>
        <span class="n">typevartuple_index</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="n">typevartuple_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;More than one TypeVarTuple parameter in </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">typevartuple_index</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">plen</span> <span class="o">-</span> <span class="n">typevartuple_index</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">var_tuple_index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">fillarg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="n">subargs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;__typing_unpacked_tuple_args__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">subargs</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">subargs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">var_tuple_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;More than one unpacked arbitrary-length tuple argument&quot;</span><span class="p">)</span>
                    <span class="n">var_tuple_index</span> <span class="o">=</span> <span class="n">k</span>
                    <span class="n">fillarg</span> <span class="o">=</span> <span class="n">subargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">var_tuple_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">var_tuple_index</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">var_tuple_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">&gt;</span> <span class="n">alen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too few arguments for </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">;&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected at least </span><span class="si">{</span><span class="n">plen</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="o">*</span><span class="n">args</span><span class="p">[:</span><span class="n">left</span><span class="p">],</span>
            <span class="o">*</span><span class="p">([</span><span class="n">fillarg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">typevartuple_index</span> <span class="o">-</span> <span class="n">left</span><span class="p">)),</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">left</span><span class="p">:</span> <span class="n">alen</span> <span class="o">-</span> <span class="n">right</span><span class="p">]),</span>
            <span class="o">*</span><span class="p">([</span><span class="n">fillarg</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">plen</span> <span class="o">-</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">-</span> <span class="n">typevartuple_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">alen</span> <span class="o">-</span> <span class="n">right</span><span class="p">:],</span>
        <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ParamSpecArgs</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The args for a ParamSpec object.</span>

<span class="sd">    Given a ParamSpec object P, P.args is an instance of ParamSpecArgs.</span>

<span class="sd">    ParamSpecArgs objects have a reference back to their ParamSpec:</span>

<span class="sd">       P.args.__origin__ is P</span>

<span class="sd">    This type is meant for runtime introspection and has no special meaning to</span>
<span class="sd">    static type checkers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">=</span> <span class="n">origin</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.args&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParamSpecArgs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ParamSpecKwargs</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The kwargs for a ParamSpec object.</span>

<span class="sd">    Given a ParamSpec object P, P.kwargs is an instance of ParamSpecKwargs.</span>

<span class="sd">    ParamSpecKwargs objects have a reference back to their ParamSpec:</span>

<span class="sd">       P.kwargs.__origin__ is P</span>

<span class="sd">    This type is meant for runtime introspection and has no special meaning to</span>
<span class="sd">    static type checkers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">=</span> <span class="n">origin</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.kwargs&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParamSpecKwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ParamSpec</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_Immutable</span><span class="p">,</span> <span class="n">_BoundVarianceMixin</span><span class="p">,</span> <span class="n">_PickleUsingNameMixin</span><span class="p">,</span>
                <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parameter specification variable.</span>

<span class="sd">    Usage::</span>

<span class="sd">       P = ParamSpec(&#39;P&#39;)</span>

<span class="sd">    Parameter specification variables exist primarily for the benefit of static</span>
<span class="sd">    type checkers.  They are used to forward the parameter types of one</span>
<span class="sd">    callable to another callable, a pattern commonly found in higher order</span>
<span class="sd">    functions and decorators.  They are only valid when used in ``Concatenate``,</span>
<span class="sd">    or as the first argument to ``Callable``, or as parameters for user-defined</span>
<span class="sd">    Generics.  See class Generic for more information on generic types.  An</span>
<span class="sd">    example for annotating a decorator::</span>

<span class="sd">       T = TypeVar(&#39;T&#39;)</span>
<span class="sd">       P = ParamSpec(&#39;P&#39;)</span>

<span class="sd">       def add_logging(f: Callable[P, T]) -&gt; Callable[P, T]:</span>
<span class="sd">           &#39;&#39;&#39;A type-safe decorator to add logging to a function.&#39;&#39;&#39;</span>
<span class="sd">           def inner(*args: P.args, **kwargs: P.kwargs) -&gt; T:</span>
<span class="sd">               logging.info(f&#39;{f.__name__} was called&#39;)</span>
<span class="sd">               return f(*args, **kwargs)</span>
<span class="sd">           return inner</span>

<span class="sd">       @add_logging</span>
<span class="sd">       def add_two(x: float, y: float) -&gt; float:</span>
<span class="sd">           &#39;&#39;&#39;Add two numbers together.&#39;&#39;&#39;</span>
<span class="sd">           return x + y</span>

<span class="sd">    Parameter specification variables can be introspected. e.g.:</span>

<span class="sd">       P.__name__ == &#39;P&#39;</span>

<span class="sd">    Note that only parameter specification variables defined in global scope can</span>
<span class="sd">    be pickled.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ParamSpecArgs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ParamSpecKwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">bound</span><span class="p">,</span> <span class="n">covariant</span><span class="p">,</span> <span class="n">contravariant</span><span class="p">)</span>
        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;Expected a type.&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected a list of types, an ellipsis, &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;ParamSpec, or Concatenate. Got </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arg</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_prepare_subst__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alias</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">alias</span><span class="o">.</span><span class="n">__parameters__</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too few arguments for </span><span class="si">{</span><span class="n">alias</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Special case where Z[[int, str, bool]] == Z[int, str, bool] in PEP 612.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">assert</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
        <span class="c1"># Convert lists to tuples to help other libraries cache the results.</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">args</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;__&#39;</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_BaseGenericAlias</span><span class="p">(</span><span class="n">_Final</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The central part of the internal API.</span>

<span class="sd">    This represents a generic version of type &#39;origin&#39; with type arguments &#39;params&#39;.</span>
<span class="sd">    There are two kind of these aliases: user defined and special. The special ones</span>
<span class="sd">    are wrappers around builtin collections and ABCs in collections.abc. These must</span>
<span class="sd">    have &#39;name&#39; always set. If &#39;inst&#39; is False, then the alias can&#39;t be instantiated;</span>
<span class="sd">    this is used by e.g. typing.List and typing.Dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inst</span> <span class="o">=</span> <span class="n">inst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__slots__</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># This is not documented.</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2"> cannot be instantiated; &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;use </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">() instead&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">__orig_class__</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="c1"># Some objects raise TypeError (or something even more exotic)</span>
        <span class="c1"># if you try to set attributes on them; we guard against that here</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Generic</span><span class="p">):</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Generic</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="c1"># We are careful for copy and pickle.</span>
        <span class="c1"># Also for simplicity we don&#39;t relay any dunder names</span>
        <span class="k">if</span> <span class="s1">&#39;__origin__&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_inst&#39;</span><span class="p">,</span> <span class="s1">&#39;_nparams&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;_paramspec_tvars&#39;</span><span class="p">}:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Subscripted generics cannot be used with&quot;</span>
                        <span class="s2">&quot; class and instance checks&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">()</span>
                <span class="o">+</span> <span class="p">[</span><span class="n">attr</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_dunder</span><span class="p">(</span><span class="n">attr</span><span class="p">)]))</span>


<span class="c1"># Special typing constructs Union, Optional, Generic, Callable and Tuple</span>
<span class="c1"># use three special attributes for internal bookkeeping of generic types:</span>
<span class="c1"># * __parameters__ is a tuple of unique free type parameters of a generic</span>
<span class="c1">#   type, for example, Dict[T, T].__parameters__ == (T,);</span>
<span class="c1"># * __origin__ keeps a reference to a type that was subscripted,</span>
<span class="c1">#   e.g., Union[T, int].__origin__ == Union, or the non-generic version of</span>
<span class="c1">#   the type.</span>
<span class="c1"># * __args__ is a tuple of all arguments used in subscripting,</span>
<span class="c1">#   e.g., Dict[T, int].__args__ == (T, int).</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_GenericAlias</span><span class="p">(</span><span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="c1"># The type of parameterized generics.</span>
    <span class="c1">#</span>
    <span class="c1"># That is, for example, `type(List[int])` is `_GenericAlias`.</span>
    <span class="c1">#</span>
    <span class="c1"># Objects which are instances of this class include:</span>
    <span class="c1"># * Parameterized container types, e.g. `Tuple[int]`, `List[int]`.</span>
    <span class="c1">#  * Note that native container types, e.g. `tuple`, `list`, use</span>
    <span class="c1">#    `types.GenericAlias` instead.</span>
    <span class="c1"># * Parameterized classes:</span>
    <span class="c1">#     T = TypeVar(&#39;T&#39;)</span>
    <span class="c1">#     class C(Generic[T]): pass</span>
    <span class="c1">#     # C[int] is a _GenericAlias</span>
    <span class="c1"># * `Callable` aliases, generic `Callable` aliases, and</span>
    <span class="c1">#   parameterized `Callable` aliases:</span>
    <span class="c1">#     T = TypeVar(&#39;T&#39;)</span>
    <span class="c1">#     # _CallableGenericAlias inherits from _GenericAlias.</span>
    <span class="c1">#     A = Callable[[], None]  # _CallableGenericAlias</span>
    <span class="c1">#     B = Callable[[T], None]  # _CallableGenericAlias</span>
    <span class="c1">#     C = B[int]  # _CallableGenericAlias</span>
    <span class="c1"># * Parameterized `Final`, `ClassVar` and `TypeGuard`:</span>
    <span class="c1">#     # All _GenericAlias</span>
    <span class="c1">#     Final[int]</span>
    <span class="c1">#     ClassVar[float]</span>
    <span class="c1">#     TypeVar[bool]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="o">...</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">_TypingEllipsis</span> <span class="k">else</span>
                              <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span> <span class="o">=</span> <span class="n">_collect_parameters</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_paramspec_tvars</span> <span class="o">=</span> <span class="n">_paramspec_tvars</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@_tp_cache</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># Parameterizes an already-parameterized object.</span>
        <span class="c1">#</span>
        <span class="c1"># For example, we arrive here doing something like:</span>
        <span class="c1">#   T1 = TypeVar(&#39;T1&#39;)</span>
        <span class="c1">#   T2 = TypeVar(&#39;T2&#39;)</span>
        <span class="c1">#   T3 = TypeVar(&#39;T3&#39;)</span>
        <span class="c1">#   class A(Generic[T1]): pass</span>
        <span class="c1">#   B = A[T2]  # B is a _GenericAlias</span>
        <span class="c1">#   C = B[T3]  # Invokes _GenericAlias.__getitem__</span>
        <span class="c1">#</span>
        <span class="c1"># We also arrive here when parameterizing a generic `Callable` alias:</span>
        <span class="c1">#   T = TypeVar(&#39;T&#39;)</span>
        <span class="c1">#   C = Callable[[T], None]</span>
        <span class="c1">#   C[int]  # Invokes _GenericAlias.__getitem__</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
            <span class="c1"># Can&#39;t subscript Generic[...] or Protocol[...].</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subscript already-subscripted </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2"> is not a generic class&quot;</span><span class="p">)</span>

        <span class="c1"># Preprocess `args`.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">_unpack_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_determine_new_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">new_args</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_determine_new_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="c1"># Determines new __args__ for __getitem__.</span>
        <span class="c1">#</span>
        <span class="c1"># For example, suppose we had:</span>
        <span class="c1">#   T1 = TypeVar(&#39;T1&#39;)</span>
        <span class="c1">#   T2 = TypeVar(&#39;T2&#39;)</span>
        <span class="c1">#   class A(Generic[T1, T2]): pass</span>
        <span class="c1">#   T3 = TypeVar(&#39;T3&#39;)</span>
        <span class="c1">#   B = A[int, T3]</span>
        <span class="c1">#   C = B[str]</span>
        <span class="c1"># `B.__args__` is `(int, T3)`, so `C.__args__` should be `(int, str)`.</span>
        <span class="c1"># Unfortunately, this is harder than it looks, because if `T3` is</span>
        <span class="c1"># anything more exotic than a plain `TypeVar`, we need to consider</span>
        <span class="c1"># edge cases.</span>

        <span class="n">params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parameters__</span>
        <span class="c1"># In the example above, this would be {T3: str}</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">prepare</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;__typing_prepare_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prepare</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">plen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alen</span> <span class="o">!=</span> <span class="n">plen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Too </span><span class="si">{</span><span class="s1">&#39;many&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">alen</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">plen</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;few&#39;</span><span class="si">}</span><span class="s2"> arguments for </span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s2">;&quot;</span>
                            <span class="sa">f</span><span class="s2">&quot; actual </span><span class="si">{</span><span class="n">alen</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">plen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">new_arg_by_param</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_substitution</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_substitution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a list of new type arguments.&quot;&quot;&quot;</span>
        <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">old_arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_arg</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">substfunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="s1">&#39;__typing_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">substfunc</span><span class="p">:</span>
                <span class="n">new_arg</span> <span class="o">=</span> <span class="n">substfunc</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">old_arg</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subparams</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="p">())</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">subparams</span><span class="p">:</span>
                    <span class="n">new_arg</span> <span class="o">=</span> <span class="n">old_arg</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subargs</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">subparams</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
                            <span class="n">subargs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">subargs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg_by_param</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
                    <span class="n">new_arg</span> <span class="o">=</span> <span class="n">old_arg</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">subargs</span><span class="p">)]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># Consider the following `Callable`.</span>
                <span class="c1">#   C = Callable[[int], str]</span>
                <span class="c1"># Here, `C.__args__` should be (int, str) - NOT ([int], str).</span>
                <span class="c1"># That means that if we had something like...</span>
                <span class="c1">#   P = ParamSpec(&#39;P&#39;)</span>
                <span class="c1">#   T = TypeVar(&#39;T&#39;)</span>
                <span class="c1">#   C = Callable[P, T]</span>
                <span class="c1">#   D = C[[int, str], float]</span>
                <span class="c1"># ...we need to be careful; `new_args` should end up as</span>
                <span class="c1"># `(int, str, float)` rather than `([int, str], float)`.</span>
                <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">old_arg</span><span class="p">):</span>
                <span class="c1"># Consider the following `_GenericAlias`, `B`:</span>
                <span class="c1">#   class A(Generic[*Ts]): ...</span>
                <span class="c1">#   B = A[T, *Ts]</span>
                <span class="c1"># If we then do:</span>
                <span class="c1">#   B[float, int, str]</span>
                <span class="c1"># The `new_arg` corresponding to `T` will be `float`, and the</span>
                <span class="c1"># `new_arg` corresponding to `*Ts` will be `(int, str)`. We</span>
                <span class="c1"># should join all these types together in a flat list</span>
                <span class="c1"># `(float, int, str)` - so again, we should `extend`.</span>
                <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># Corner case:</span>
                <span class="c1">#    P = ParamSpec(&#39;P&#39;)</span>
                <span class="c1">#    T = TypeVar(&#39;T&#39;)</span>
                <span class="c1">#    class Base(Generic[P]): ...</span>
                <span class="c1"># Can be substituted like this:</span>
                <span class="c1">#    X = Base[[int, T]]</span>
                <span class="c1"># In this case, `old_arg` will be a tuple:</span>
                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_make_substitution</span><span class="p">(</span><span class="n">old_arg</span><span class="p">,</span> <span class="n">new_arg_by_param</span><span class="p">)),</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_args</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">,</span>
                              <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_paramspec_tvars</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">_type_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># To ensure the repr is eval-able.</span>
            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot;()&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">[</span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s1">]&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="nb">globals</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">args</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">_SpecialForm</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subclass </span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">:</span>  <span class="c1"># generic version of an ABC or built-in class</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__mro_entries__</span><span class="p">(</span><span class="n">bases</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">Protocol</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">bases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">Unpack</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>


<span class="c1"># _nparams is the number of accepted parameters, e.g. 0 for Hashable,</span>
<span class="c1"># 1 for List and 2 for Dict.  It may be -1 if variable number of</span>
<span class="c1"># parameters are accepted (needs custom __getitem__).</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_SpecialGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">nparams</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="n">inst</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span> <span class="o">=</span> <span class="n">nparams</span>
        <span class="k">if</span> <span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">==</span> <span class="s1">&#39;builtins&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;A generic version of </span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;A generic version of </span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">origin</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.&#39;</span>

    <span class="nd">@_tp_cache</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Parameters to generic types must be types.&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
        <span class="n">_check_generic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nparams</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                             <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;typing.&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_SpecialGenericAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>

<span class="k">class</span><span class="w"> </span><span class="nc">_CallableGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">==</span> <span class="s1">&#39;Callable&#39;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;typing.Callable&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;[[</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span><span class="si">}</span><span class="s1">], &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">_is_param_expr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span><span class="n">Callable</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_CallableType</span><span class="p">(</span><span class="n">_SpecialGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_CallableGenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                                     <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inst</span><span class="p">,</span>
                                     <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Callable must be used as &quot;</span>
                            <span class="s2">&quot;Callable[[arg, ...], result].&quot;</span><span class="p">)</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">params</span>
        <span class="c1"># This relaxes what args can be on purpose to allow things like</span>
        <span class="c1"># PEP 612 ParamSpec.  Responsibility for whether a user is using</span>
        <span class="c1"># Callable[...] properly is deferred to static type checkers.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem_inner__</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@_tp_cache</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__getitem_inner__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">params</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Callable[args, result]: result must be a type.&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">((</span><span class="n">_TypingEllipsis</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">,)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">args</span> <span class="o">+</span> <span class="p">(</span><span class="n">result</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_TupleType</span><span class="p">(</span><span class="n">_SpecialGenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="nd">@_tp_cache</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tuple[t, ...]: t must be a type.&quot;</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">((</span><span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">_TypingEllipsis</span><span class="p">))</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Tuple[t0, t1, ...]: each t must be a type.&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_check</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_UnionGenericAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">params</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">_UnionGenericAlias</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># fast path</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># not hashable, slow path</span>
            <span class="k">return</span> <span class="n">_compare_args_orderless</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;typing.Optional[</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span>
            <span class="k">elif</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;typing.Optional[</span><span class="si">{</span><span class="n">_type_repr</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="si">}</span><span class="s1">]&#39;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">arg</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__reduce__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="n">Union</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_value_and_type_iter</span><span class="p">(</span><span class="n">parameters</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_LiteralGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_LiteralGenericAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">__args__</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">_value_and_type_iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)))</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_ConcatenateGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">_ConcatenateGenericAlias</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">*</span><span class="n">params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Unpack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Type unpack operator.</span>

<span class="sd">    The type unpack operator takes the child types from some container type,</span>
<span class="sd">    such as `tuple[int, str]` or a `TypeVarTuple`, and &#39;pulls them out&#39;.</span>

<span class="sd">    For example::</span>

<span class="sd">        # For some generic class `Foo`:</span>
<span class="sd">        Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]</span>

<span class="sd">        Ts = TypeVarTuple(&#39;Ts&#39;)</span>
<span class="sd">        # Specifies that `Bar` is generic in an arbitrary number of types.</span>
<span class="sd">        # (Think of `Ts` as a tuple of an arbitrary number of individual</span>
<span class="sd">        #  `TypeVar`s, which the `Unpack` is &#39;pulling out&#39; directly into the</span>
<span class="sd">        #  `Generic[]`.)</span>
<span class="sd">        class Bar(Generic[Unpack[Ts]]): ...</span>
<span class="sd">        Bar[int]  # Valid</span>
<span class="sd">        Bar[int, str]  # Also valid</span>

<span class="sd">    From Python 3.11, this can also be done using the `*` operator::</span>

<span class="sd">        Foo[*tuple[int, str]]</span>
<span class="sd">        class Bar(Generic[*Ts]): ...</span>

<span class="sd">    Note that there is only some runtime checking of this operator. Not</span>
<span class="sd">    everything the runtime allows may be accepted by static type checkers.</span>

<span class="sd">    For more information, see PEP 646.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">}</span><span class="s1"> accepts only single type.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_UnpackGenericAlias</span><span class="p">(</span><span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">item</span><span class="p">,))</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_UnpackGenericAlias</span><span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># `Unpack` only takes one argument, so __args__ should contain only</span>
        <span class="c1"># a single item.</span>
        <span class="k">return</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__typing_is_unpacked_typevartuple__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">args</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_unpacked_tuple_args__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">arg</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__args__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">arg</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="nb">tuple</span>
            <span class="k">return</span> <span class="n">arg</span><span class="o">.</span><span class="n">__args__</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__typing_is_unpacked_typevartuple__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Unpack</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">TypeVarTuple</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Generic</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract base class for generic types.</span>

<span class="sd">    A generic type is typically declared by inheriting from</span>
<span class="sd">    this class parameterized with one or more type variables.</span>
<span class="sd">    For example, a generic mapping type might be defined as::</span>

<span class="sd">      class Mapping(Generic[KT, VT]):</span>
<span class="sd">          def __getitem__(self, key: KT) -&gt; VT:</span>
<span class="sd">              ...</span>
<span class="sd">          # Etc.</span>

<span class="sd">    This class can then be used as follows::</span>

<span class="sd">      def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:</span>
<span class="sd">          try:</span>
<span class="sd">              return mapping[key]</span>
<span class="sd">          except KeyError:</span>
<span class="sd">              return default</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_is_protocol</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@_tp_cache</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__class_getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parameterizes a generic class.</span>

<span class="sd">        At least, parameterizing a generic class is the *main* thing this method</span>
<span class="sd">        does. For example, for some generic class `Foo`, this is called when we</span>
<span class="sd">        do `Foo[int]` - there, with `cls=Foo` and `params=int`.</span>

<span class="sd">        However, note that this method is also called when defining generic</span>
<span class="sd">        classes in the first place with `class Foo(Generic[T]): ...`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>

        <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_type_convert</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">Protocol</span><span class="p">):</span>
            <span class="c1"># Generic and Protocol can only be subscripted with unique type variables.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameter list to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2">[...] cannot be empty&quot;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_typevar_like</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameters to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">[...] must all be type variables &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;or parameter specification variables.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameters to </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">[...] must all be unique&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Subscripting a regular Generic subclass.</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">:</span>
                <span class="n">prepare</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;__typing_prepare_subst__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prepare</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">params</span> <span class="o">=</span> <span class="n">prepare</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="n">_check_generic</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">))</span>

            <span class="n">new_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">new_arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">TypeVarTuple</span><span class="p">):</span>
                    <span class="n">new_args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_arg</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_args</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span>
                             <span class="n">_paramspec_tvars</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">tvars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s1">&#39;__orig_bases__&#39;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">error</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span> <span class="ow">and</span>
                        <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s1">&#39;Protocol&#39;</span> <span class="ow">and</span>
                        <span class="nb">type</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_TypedDictMeta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Cannot inherit from plain Generic&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;__orig_bases__&#39;</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">tvars</span> <span class="o">=</span> <span class="n">_collect_parameters</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span><span class="p">)</span>
            <span class="c1"># Look for Generic[T1, ..., Tn].</span>
            <span class="c1"># If found, tvars must be a subset of it.</span>
            <span class="c1"># If not found, tvars is it.</span>
            <span class="c1"># Also check for and reject plain Generic,</span>
            <span class="c1"># and reject multiple Generic[...].</span>
            <span class="n">gvars</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">__orig_bases__</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">base</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">gvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="s2">&quot;Cannot inherit from Generic[...] multiple times.&quot;</span><span class="p">)</span>
                    <span class="n">gvars</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">__parameters__</span>
            <span class="k">if</span> <span class="n">gvars</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tvarset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">tvars</span><span class="p">)</span>
                <span class="n">gvarset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">gvars</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tvarset</span> <span class="o">&lt;=</span> <span class="n">gvarset</span><span class="p">:</span>
                    <span class="n">s_vars</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tvars</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gvarset</span><span class="p">)</span>
                    <span class="n">s_args</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gvars</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Some type variables (</span><span class="si">{</span><span class="n">s_vars</span><span class="si">}</span><span class="s2">) are&quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot; not listed in Generic[</span><span class="si">{</span><span class="n">s_args</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
                <span class="n">tvars</span> <span class="o">=</span> <span class="n">gvars</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">__parameters__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tvars</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_TypingEllipsis</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal placeholder for ... (ellipsis).&quot;&quot;&quot;</span>


<span class="n">_TYPING_INTERNALS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__parameters__&#39;</span><span class="p">,</span> <span class="s1">&#39;__orig_bases__&#39;</span><span class="p">,</span>  <span class="s1">&#39;__orig_class__&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;__final__&#39;</span><span class="p">]</span>

<span class="n">_SPECIAL_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__abstractmethods__&#39;</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__new__&#39;</span><span class="p">,</span> <span class="s1">&#39;__slots__&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;__subclasshook__&#39;</span><span class="p">,</span> <span class="s1">&#39;__weakref__&#39;</span><span class="p">,</span> <span class="s1">&#39;__class_getitem__&#39;</span><span class="p">]</span>

<span class="c1"># These special attributes will be not collected as protocol members.</span>
<span class="n">EXCLUDED_ATTRIBUTES</span> <span class="o">=</span> <span class="n">_TYPING_INTERNALS</span> <span class="o">+</span> <span class="n">_SPECIAL_NAMES</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;_MutableMapping__marker&#39;</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collect protocol members from a protocol class objects.</span>

<span class="sd">    This includes names actually defined in the class dictionary, as well</span>
<span class="sd">    as names that appear in annotations. Special names (above) are skipped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>  <span class="c1"># without object</span>
        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Protocol&#39;</span><span class="p">,</span> <span class="s1">&#39;Generic&#39;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">annotations</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_abc_&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">EXCLUDED_ATTRIBUTES</span><span class="p">:</span>
                <span class="n">attrs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">attrs</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_is_callable_members_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
    <span class="c1"># PEP 544 prohibits using issubclass() with protocols that have non-method members.</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_no_init_or_replace_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Protocols cannot be instantiated&#39;</span><span class="p">)</span>

    <span class="c1"># Already using a custom `__init__`. No need to calculate correct</span>
    <span class="c1"># `__init__` to call. This can lead to RecursionError. See bpo-45121.</span>
    <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_no_init_or_replace_init</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># Initially, `__init__` of a protocol subclass is set to `_no_init_or_replace_init`.</span>
    <span class="c1"># The first instantiation of the subclass will call `_no_init_or_replace_init` which</span>
    <span class="c1"># searches for a proper new `__init__` in the MRO. The new `__init__`</span>
    <span class="c1"># replaces the subclass&#39; old `__init__` (ie `_no_init_or_replace_init`). Subsequent</span>
    <span class="c1"># instantiation of the protocol subclass will thus use the new</span>
    <span class="c1"># `__init__` and no longer call `_no_init_or_replace_init`.</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
        <span class="n">init</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="n">_no_init_or_replace_init</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_no_init_or_replace_init</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">init</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># should not happen</span>
        <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__init__</span>

    <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_caller</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;__main__&#39;</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">f_globals</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>  <span class="c1"># For platforms without _getframe()</span>
        <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_allow_reckless_class_checks</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Allow instance and class checks for special stdlib modules.</span>

<span class="sd">    The abc and functools modules indiscriminately call isinstance() and</span>
<span class="sd">    issubclass() on the whole MRO of a user class, which may contain protocols.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_caller</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;abc&#39;</span><span class="p">,</span> <span class="s1">&#39;functools&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span>


<span class="n">_PROTO_ALLOWLIST</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;collections.abc&#39;</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">&#39;Callable&#39;</span><span class="p">,</span> <span class="s1">&#39;Awaitable&#39;</span><span class="p">,</span> <span class="s1">&#39;Iterable&#39;</span><span class="p">,</span> <span class="s1">&#39;Iterator&#39;</span><span class="p">,</span> <span class="s1">&#39;AsyncIterable&#39;</span><span class="p">,</span>
        <span class="s1">&#39;Hashable&#39;</span><span class="p">,</span> <span class="s1">&#39;Sized&#39;</span><span class="p">,</span> <span class="s1">&#39;Container&#39;</span><span class="p">,</span> <span class="s1">&#39;Collection&#39;</span><span class="p">,</span> <span class="s1">&#39;Reversible&#39;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">&#39;contextlib&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;AbstractContextManager&#39;</span><span class="p">,</span> <span class="s1">&#39;AbstractAsyncContextManager&#39;</span><span class="p">],</span>
<span class="p">}</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_ProtocolMeta</span><span class="p">(</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="c1"># This metaclass is really unfortunate and exists only because of</span>
    <span class="c1"># the lack of __instancehook__.</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="c1"># We need this method for situations where attributes are</span>
        <span class="c1"># assigned in __init__.</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="n">_allow_reckless_class_checks</span><span class="p">(</span><span class="n">depth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Instance and class checks can only be used with&quot;</span>
                            <span class="s2">&quot; @runtime_checkable protocols&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">_is_callable_members_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span> <span class="ow">and</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="n">instance</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="c1"># All *methods* can be blocked by setting them to None.</span>
                    <span class="p">(</span><span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="ow">or</span>
                     <span class="nb">getattr</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">)):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Protocol</span><span class="p">(</span><span class="n">Generic</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ProtocolMeta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for protocol classes.</span>

<span class="sd">    Protocol classes are defined as::</span>

<span class="sd">        class Proto(Protocol):</span>
<span class="sd">            def meth(self) -&gt; int:</span>
<span class="sd">                ...</span>

<span class="sd">    Such classes are primarily used with static type checkers that recognize</span>
<span class="sd">    structural subtyping (static duck-typing).</span>

<span class="sd">    For example::</span>

<span class="sd">        class C:</span>
<span class="sd">            def meth(self) -&gt; int:</span>
<span class="sd">                return 0</span>

<span class="sd">        def func(x: Proto) -&gt; int:</span>
<span class="sd">            return x.meth()</span>

<span class="sd">        func(C())  # Passes static type check</span>

<span class="sd">    See PEP 544 for details. Protocol classes decorated with</span>
<span class="sd">    @typing.runtime_checkable act as simple-minded runtime protocols that check</span>
<span class="sd">    only the presence of given attributes, ignoring their type signatures.</span>
<span class="sd">    Protocol classes can be generic, they are defined as::</span>

<span class="sd">        class GenProto(Protocol[T]):</span>
<span class="sd">            def meth(self) -&gt; T:</span>
<span class="sd">                ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">_is_protocol</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_is_runtime_protocol</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Determine if this is a protocol or a concrete subclass.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">Protocol</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">)</span>

        <span class="c1"># Set (or override) the protocol subclass hook.</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_proto_hook</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_is_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">NotImplemented</span>

            <span class="c1"># First, perform various sanity checks.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;_is_runtime_protocol&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">_allow_reckless_class_checks</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Instance and class checks can only be used with&quot;</span>
                                <span class="s2">&quot; @runtime_checkable protocols&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_callable_members_only</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">_allow_reckless_class_checks</span><span class="p">():</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Protocols with non-method members&quot;</span>
                                <span class="s2">&quot; don&#39;t support issubclass()&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="c1"># Same error message as for issubclass(1, int).</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;issubclass() arg 1 must be a class&#39;</span><span class="p">)</span>

            <span class="c1"># Second, perform the actual structural compatibility check.</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">_get_protocol_attrs</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                    <span class="c1"># Check if the members appears in the class dictionary...</span>
                    <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">NotImplemented</span>
                        <span class="k">break</span>

                    <span class="c1"># ...or in annotations, if it is a sub-protocol.</span>
                    <span class="n">annotations</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span> <span class="ow">and</span>
                            <span class="n">attr</span> <span class="ow">in</span> <span class="n">annotations</span> <span class="ow">and</span>
                            <span class="nb">issubclass</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">):</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">NotImplemented</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="s1">&#39;__subclasshook__&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">__subclasshook__</span> <span class="o">=</span> <span class="n">_proto_hook</span>

        <span class="c1"># We have nothing more to do for non-protocols...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># ... otherwise check consistency of bases, and prohibit instantiation.</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">base</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">base</span><span class="o">.</span><span class="vm">__module__</span> <span class="ow">in</span> <span class="n">_PROTO_ALLOWLIST</span> <span class="ow">and</span>
                    <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">_PROTO_ALLOWLIST</span><span class="p">[</span><span class="n">base</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span> <span class="ow">or</span>
                    <span class="nb">issubclass</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Protocols can only inherit from other&#39;</span>
                                <span class="s1">&#39; protocols, got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="ow">is</span> <span class="n">Protocol</span><span class="o">.</span><span class="fm">__init__</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="fm">__init__</span> <span class="o">=</span> <span class="n">_no_init_or_replace_init</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_AnnotatedAlias</span><span class="p">(</span><span class="n">_NotIterable</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">_root</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Runtime representation of an annotated type.</span>

<span class="sd">    At its core &#39;Annotated[t, dec1, dec2, ...]&#39; is an alias for the type &#39;t&#39;</span>
<span class="sd">    with extra annotations. The alias behaves like a normal typing alias.</span>
<span class="sd">    Instantiating is the same as instantiating the underlying type; binding</span>
<span class="sd">    it to types is also the same.</span>

<span class="sd">    The metadata itself is stored in a &#39;__metadata__&#39; attribute as a tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">metadata</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">+</span> <span class="n">metadata</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">__origin__</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">=</span> <span class="n">metadata</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy_with</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">new_type</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_AnnotatedAlias</span><span class="p">(</span><span class="n">new_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;typing.Annotated[</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">_type_repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">),</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">operator</span><span class="o">.</span><span class="n">getitem</span><span class="p">,</span> <span class="p">(</span>
            <span class="n">Annotated</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__origin__</span>
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metadata__</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">}:</span>
            <span class="k">return</span> <span class="s1">&#39;Annotated&#39;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Annotated</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add context-specific metadata to a type.</span>

<span class="sd">    Example: Annotated[int, runtime_check.Unsigned] indicates to the</span>
<span class="sd">    hypothetical runtime_check module that this type is an unsigned int.</span>
<span class="sd">    Every other consumer of this type can ignore this metadata and treat</span>
<span class="sd">    this type as int.</span>

<span class="sd">    The first argument to Annotated must be a valid type.</span>

<span class="sd">    Details:</span>

<span class="sd">    - It&#39;s an error to call `Annotated` with less than two arguments.</span>
<span class="sd">    - Access the metadata via the ``__metadata__`` attribute::</span>

<span class="sd">        assert Annotated[int, &#39;$&#39;].__metadata__ == (&#39;$&#39;,)</span>

<span class="sd">    - Nested Annotated types are flattened::</span>

<span class="sd">        assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]</span>

<span class="sd">    - Instantiating an annotated type is equivalent to instantiating the</span>
<span class="sd">    underlying type::</span>

<span class="sd">        assert Annotated[C, Ann1](5) == C(5)</span>

<span class="sd">    - Annotated can be used as a generic type alias::</span>

<span class="sd">        Optimized: TypeAlias = Annotated[T, runtime.Optimize()]</span>
<span class="sd">        assert Optimized[int] == Annotated[int, runtime.Optimize()]</span>

<span class="sd">        OptimizedList: TypeAlias = Annotated[list[T], runtime.Optimize()]</span>
<span class="sd">        assert OptimizedList[int] == Annotated[list[int], runtime.Optimize()]</span>

<span class="sd">    - Annotated cannot be used with an unpacked TypeVarTuple::</span>

<span class="sd">        Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid</span>

<span class="sd">      This would be equivalent to::</span>

<span class="sd">        Annotated[T1, T2, T3, ..., Ann1]</span>

<span class="sd">      where T1, T2 etc. are TypeVars, which would be invalid, because</span>
<span class="sd">      only one type should be passed to Annotated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Type Annotated cannot be instantiated.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__class_getitem__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_class_getitem_inner</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

    <span class="nd">@_tp_cache</span><span class="p">(</span><span class="n">typed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_class_getitem_inner</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Annotated[...] should be used &quot;</span>
                            <span class="s2">&quot;with at least two arguments (a type and an &quot;</span>
                            <span class="s2">&quot;annotation).&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_is_unpacked_typevartuple</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Annotated[...] should not be used with an &quot;</span>
                            <span class="s2">&quot;unpacked TypeVarTuple&quot;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Annotated[t, ...]: t must be a type.&quot;</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span><span class="p">,</span> <span class="n">allow_special_forms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="n">_AnnotatedAlias</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">metadata</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Cannot subclass </span><span class="si">{}</span><span class="s2">.Annotated&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">runtime_checkable</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mark a protocol class as a runtime protocol.</span>

<span class="sd">    Such protocol can be used with isinstance() and issubclass().</span>
<span class="sd">    Raise TypeError if applied to a non-protocol class.</span>
<span class="sd">    This allows a simple-minded structural check very similar to</span>
<span class="sd">    one trick ponies in collections.abc such as Iterable.</span>

<span class="sd">    For example::</span>

<span class="sd">        @runtime_checkable</span>
<span class="sd">        class Closable(Protocol):</span>
<span class="sd">            def close(self): ...</span>

<span class="sd">        assert isinstance(open(&#39;/some/file&#39;), Closable)</span>

<span class="sd">    Warning: this will check only the presence of the required methods,</span>
<span class="sd">    not their type signatures!</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_is_protocol</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;@runtime_checkable can be only applied to protocol classes,&#39;</span>
                        <span class="s1">&#39; got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="bp">cls</span><span class="o">.</span><span class="n">_is_runtime_protocol</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="bp">cls</span>


<span class="k">def</span><span class="w"> </span><span class="nf">cast</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cast a value to a type.</span>

<span class="sd">    This returns the value unchanged.  To the type checker this</span>
<span class="sd">    signals that the return value has the designated type, but at</span>
<span class="sd">    runtime we intentionally don&#39;t check anything (we want this</span>
<span class="sd">    to be as fast as possible).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span><span class="w"> </span><span class="nf">assert_type</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="o">/</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ask a static type checker to confirm that the value is of the given type.</span>

<span class="sd">    At runtime this does nothing: it returns the first argument unchanged with no</span>
<span class="sd">    checks or side effects, no matter the actual type of the argument.</span>

<span class="sd">    When a static type checker encounters a call to assert_type(), it</span>
<span class="sd">    emits an error if the value is not of the specified type::</span>

<span class="sd">        def greet(name: str) -&gt; None:</span>
<span class="sd">            assert_type(name, str)  # OK</span>
<span class="sd">            assert_type(name, int)  # type checker error</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="n">_allowed_types</span> <span class="o">=</span> <span class="p">(</span><span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">BuiltinFunctionType</span><span class="p">,</span>
                  <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">,</span>
                  <span class="n">WrapperDescriptorType</span><span class="p">,</span> <span class="n">MethodWrapperType</span><span class="p">,</span> <span class="n">MethodDescriptorType</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_type_hints</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">globalns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">localns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return type hints for an object.</span>

<span class="sd">    This is often the same as obj.__annotations__, but it handles</span>
<span class="sd">    forward references encoded as string literals and recursively replaces all</span>
<span class="sd">    &#39;Annotated[T, ...]&#39; with &#39;T&#39; (unless &#39;include_extras=True&#39;).</span>

<span class="sd">    The argument may be a module, class, method, or function. The annotations</span>
<span class="sd">    are returned as a dictionary. For classes, annotations include also</span>
<span class="sd">    inherited members.</span>

<span class="sd">    TypeError is raised if the argument is not of a type that can contain</span>
<span class="sd">    annotations, and an empty dictionary is returned if no annotations are</span>
<span class="sd">    present.</span>

<span class="sd">    BEWARE -- the behavior of globalns and localns is counterintuitive</span>
<span class="sd">    (unless you are familiar with how eval() and exec() work).  The</span>
<span class="sd">    search order is locals first, then globals.</span>

<span class="sd">    - If no dict arguments are passed, an attempt is made to use the</span>
<span class="sd">      globals from obj (or the respective module&#39;s globals for classes),</span>
<span class="sd">      and these are also used as the locals.  If the object does not appear</span>
<span class="sd">      to have globals, an empty dictionary is used.  For classes, the search</span>
<span class="sd">      order is globals first then locals.</span>

<span class="sd">    - If one dict argument is passed, it is used for both globals and</span>
<span class="sd">      locals.</span>

<span class="sd">    - If two dict arguments are passed, they specify globals and</span>
<span class="sd">      locals, respectively.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__no_type_check__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="c1"># Classes require a special treatment.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="n">hints</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">base_globals</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_globals</span> <span class="o">=</span> <span class="n">globalns</span>
            <span class="n">ann</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GetSetDescriptorType</span><span class="p">):</span>
                <span class="n">ann</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">base_locals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="n">base</span><span class="p">))</span> <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">localns</span>
            <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># This is surprising, but required.  Before Python 3.10,</span>
                <span class="c1"># get_type_hints only evaluated the globalns of</span>
                <span class="c1"># a class.  To maintain backwards compatibility, we reverse</span>
                <span class="c1"># the globalns and localns order so that eval() looks into</span>
                <span class="c1"># *base_globals* first rather than *base_locals*.</span>
                <span class="c1"># This only affects ForwardRefs.</span>
                <span class="n">base_globals</span><span class="p">,</span> <span class="n">base_locals</span> <span class="o">=</span> <span class="n">base_locals</span><span class="p">,</span> <span class="n">base_globals</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ann</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">is_argument</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_class</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">base_globals</span><span class="p">,</span> <span class="n">base_locals</span><span class="p">)</span>
                <span class="n">hints</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">return</span> <span class="n">hints</span> <span class="k">if</span> <span class="n">include_extras</span> <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

    <span class="k">if</span> <span class="n">globalns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">):</span>
            <span class="n">globalns</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nsobj</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="c1"># Find globalns for the unwrapped object.</span>
            <span class="k">while</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">nsobj</span><span class="p">,</span> <span class="s1">&#39;__wrapped__&#39;</span><span class="p">):</span>
                <span class="n">nsobj</span> <span class="o">=</span> <span class="n">nsobj</span><span class="o">.</span><span class="n">__wrapped__</span>
            <span class="n">globalns</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nsobj</span><span class="p">,</span> <span class="s1">&#39;__globals__&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="k">if</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
    <span class="k">elif</span> <span class="n">localns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">localns</span> <span class="o">=</span> <span class="n">globalns</span>
    <span class="n">hints</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Return empty annotations for something that _could_ have them.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_allowed_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{!r}</span><span class="s1"> is not a module, class, method, &#39;</span>
                            <span class="s1">&#39;or function.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="n">hints</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># class-level forward refs were handled above, this must be either</span>
            <span class="c1"># a module-level annotation or a function argument annotation</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ForwardRef</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span>
                <span class="n">is_argument</span><span class="o">=</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">ModuleType</span><span class="p">),</span>
                <span class="n">is_class</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">hints</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_eval_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">globalns</span><span class="p">,</span> <span class="n">localns</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hints</span> <span class="k">if</span> <span class="n">include_extras</span> <span class="k">else</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Strip the annotations from a given type.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;__origin__&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">__origin__</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Required</span><span class="p">,</span> <span class="n">NotRequired</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_strip_annotations</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_GenericAlias</span><span class="p">):</span>
        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">copy_with</span><span class="p">(</span><span class="n">stripped_args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">):</span>
        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">GenericAlias</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,</span> <span class="n">stripped_args</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
        <span class="n">stripped_args</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_strip_annotations</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stripped_args</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">__args__</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">or_</span><span class="p">,</span> <span class="n">stripped_args</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">t</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_origin</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the unsubscripted version of a type.</span>

<span class="sd">    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,</span>
<span class="sd">    Annotated, and others. Return None for unsupported types.</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; P = ParamSpec(&#39;P&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(Literal[42]) is Literal</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(int) is None</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(ClassVar[int]) is ClassVar</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(Generic) is Generic</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(Generic[T]) is Generic</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(Union[T, int]) is Union</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(List[Tuple[T, T]][int]) is list</span>
<span class="sd">        &gt;&gt;&gt; assert get_origin(P.args) is P</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Annotated</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="p">(</span><span class="n">_BaseGenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">,</span>
                       <span class="n">ParamSpecArgs</span><span class="p">,</span> <span class="n">ParamSpecKwargs</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">tp</span><span class="o">.</span><span class="n">__origin__</span>
    <span class="k">if</span> <span class="n">tp</span> <span class="ow">is</span> <span class="n">Generic</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Generic</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_args</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get type arguments with all substitutions performed.</span>

<span class="sd">    For unions, basic simplifications used by Union constructor are performed.</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; T = TypeVar(&#39;T&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert get_args(Dict[str, int]) == (str, int)</span>
<span class="sd">        &gt;&gt;&gt; assert get_args(int) == ()</span>
<span class="sd">        &gt;&gt;&gt; assert get_args(Union[int, Union[T, int], str][int]) == (int, str)</span>
<span class="sd">        &gt;&gt;&gt; assert get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])</span>
<span class="sd">        &gt;&gt;&gt; assert get_args(Callable[[], T][int]) == ([], int)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_AnnotatedAlias</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">tp</span><span class="o">.</span><span class="n">__origin__</span><span class="p">,)</span> <span class="o">+</span> <span class="n">tp</span><span class="o">.</span><span class="n">__metadata__</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="p">(</span><span class="n">_GenericAlias</span><span class="p">,</span> <span class="n">GenericAlias</span><span class="p">)):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">__args__</span>
        <span class="k">if</span> <span class="n">_should_unflatten_callable_args</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">res</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">res</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">res</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">UnionType</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">tp</span><span class="o">.</span><span class="n">__args__</span>
    <span class="k">return</span> <span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_typeddict</span><span class="p">(</span><span class="n">tp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if an annotation is a TypedDict class.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; from typing import TypedDict</span>
<span class="sd">        &gt;&gt;&gt; class Film(TypedDict):</span>
<span class="sd">        ...     title: str</span>
<span class="sd">        ...     year: int</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; is_typeddict(Film)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; is_typeddict(dict)</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">_TypedDictMeta</span><span class="p">)</span>


<span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span> <span class="o">=</span> <span class="mi">100</span>


<span class="k">def</span><span class="w"> </span><span class="nf">assert_never</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span> <span class="n">Never</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Never</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Statically assert that a line of code is unreachable.</span>

<span class="sd">    Example::</span>

<span class="sd">        def int_or_str(arg: int | str) -&gt; None:</span>
<span class="sd">            match arg:</span>
<span class="sd">                case int():</span>
<span class="sd">                    print(&quot;It&#39;s an int&quot;)</span>
<span class="sd">                case str():</span>
<span class="sd">                    print(&quot;It&#39;s a str&quot;)</span>
<span class="sd">                case _:</span>
<span class="sd">                    assert_never(arg)</span>

<span class="sd">    If a type checker finds that a call to assert_never() is</span>
<span class="sd">    reachable, it will emit an error.</span>

<span class="sd">    At runtime, this throws an exception when called.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[:</span><span class="n">_ASSERT_NEVER_REPR_MAX_LENGTH</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span>
    <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected code to be unreachable, but got: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">no_type_check</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to indicate that annotations are not type hints.</span>

<span class="sd">    The argument must be a class or function; if it is a class, it</span>
<span class="sd">    applies recursively to all methods and classes defined in that class</span>
<span class="sd">    (but not to methods defined in its superclasses or subclasses).</span>

<span class="sd">    This mutates the function(s) or class(es) in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__qualname__&#39;</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">!=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">arg</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="n">arg</span><span class="o">.</span><span class="vm">__module__</span>
            <span class="p">):</span>
                <span class="c1"># We only modify objects that are defined in this type directly.</span>
                <span class="c1"># If classes / methods are nested in multiple layers,</span>
                <span class="c1"># we will modify them when processing their direct holders.</span>
                <span class="k">continue</span>
            <span class="c1"># Instance, class, and static methods:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">FunctionType</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="vm">__func__</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Nested types:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="n">no_type_check</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">arg</span><span class="o">.</span><span class="n">__no_type_check__</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># built-in classes</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">arg</span>


<span class="k">def</span><span class="w"> </span><span class="nf">no_type_check_decorator</span><span class="p">(</span><span class="n">decorator</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to give another decorator the @no_type_check effect.</span>

<span class="sd">    This wraps the decorator with something that wraps the decorated</span>
<span class="sd">    function in @no_type_check.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">decorator</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wrapped_decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">decorator</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">no_type_check</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">return</span> <span class="n">wrapped_decorator</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_overload_dummy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for @overload to raise when called.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;You should not call an overloaded function. &quot;</span>
        <span class="s2">&quot;A series of @overload-decorated functions &quot;</span>
        <span class="s2">&quot;outside a stub module should always be followed &quot;</span>
        <span class="s2">&quot;by an implementation that is not @overload-ed.&quot;</span><span class="p">)</span>


<span class="c1"># {module: {qualname: {firstlineno: func}}}</span>
<span class="n">_overload_registry</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">defaultdict</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">overload</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator for overloaded functions/methods.</span>

<span class="sd">    In a stub file, place two or more stub definitions for the same</span>
<span class="sd">    function in a row, each decorated with @overload.</span>

<span class="sd">    For example::</span>

<span class="sd">        @overload</span>
<span class="sd">        def utf8(value: None) -&gt; None: ...</span>
<span class="sd">        @overload</span>
<span class="sd">        def utf8(value: bytes) -&gt; bytes: ...</span>
<span class="sd">        @overload</span>
<span class="sd">        def utf8(value: str) -&gt; bytes: ...</span>

<span class="sd">    In a non-stub file (i.e. a regular .py file), do the same but</span>
<span class="sd">    follow it with an implementation.  The implementation should *not*</span>
<span class="sd">    be decorated with @overload::</span>

<span class="sd">        @overload</span>
<span class="sd">        def utf8(value: None) -&gt; None: ...</span>
<span class="sd">        @overload</span>
<span class="sd">        def utf8(value: bytes) -&gt; bytes: ...</span>
<span class="sd">        @overload</span>
<span class="sd">        def utf8(value: str) -&gt; bytes: ...</span>
<span class="sd">        def utf8(value):</span>
<span class="sd">            ...  # implementation goes here</span>

<span class="sd">    The overloads for a function can be retrieved at runtime using the</span>
<span class="sd">    get_overloads() function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># classmethod and staticmethod</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__func__&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">_overload_registry</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__module__</span><span class="p">][</span><span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">][</span><span class="n">f</span><span class="o">.</span><span class="vm">__code__</span><span class="o">.</span><span class="n">co_firstlineno</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c1"># Not a normal function; ignore.</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">_overload_dummy</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_overloads</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all defined overloads for *func* as a sequence.&quot;&quot;&quot;</span>
    <span class="c1"># classmethod and staticmethod</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s2">&quot;__func__&quot;</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="vm">__module__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_overload_registry</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">mod_dict</span> <span class="o">=</span> <span class="n">_overload_registry</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__module__</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mod_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">mod_dict</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="vm">__qualname__</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="k">def</span><span class="w"> </span><span class="nf">clear_overloads</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clear all overloads in the registry.&quot;&quot;&quot;</span>
    <span class="n">_overload_registry</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">final</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to indicate final methods and final classes.</span>

<span class="sd">    Use this decorator to indicate to type checkers that the decorated</span>
<span class="sd">    method cannot be overridden, and decorated class cannot be subclassed.</span>

<span class="sd">    For example::</span>

<span class="sd">        class Base:</span>
<span class="sd">            @final</span>
<span class="sd">            def done(self) -&gt; None:</span>
<span class="sd">                ...</span>
<span class="sd">        class Sub(Base):</span>
<span class="sd">            def done(self) -&gt; None:  # Error reported by type checker</span>
<span class="sd">                ...</span>

<span class="sd">        @final</span>
<span class="sd">        class Leaf:</span>
<span class="sd">            ...</span>
<span class="sd">        class Other(Leaf):  # Error reported by type checker</span>
<span class="sd">            ...</span>

<span class="sd">    There is no runtime checking of these properties. The decorator</span>
<span class="sd">    attempts to set the ``__final__`` attribute to ``True`` on the decorated</span>
<span class="sd">    object to allow runtime introspection.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">__final__</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># Skip the attribute silently if it is not writable.</span>
        <span class="c1"># AttributeError happens if the object has __slots__ or a</span>
        <span class="c1"># read-only property, TypeError if it&#39;s a builtin class.</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">f</span>


<span class="c1"># Some unconstrained type variables.  These are used by the container types.</span>
<span class="c1"># (These are not for export.)</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>  <span class="c1"># Any type.</span>
<span class="n">KT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;KT&#39;</span><span class="p">)</span>  <span class="c1"># Key type.</span>
<span class="n">VT</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">)</span>  <span class="c1"># Value type.</span>
<span class="n">T_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Any type covariant containers.</span>
<span class="n">V_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;V_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Any type covariant containers.</span>
<span class="n">VT_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;VT_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Value type covariant containers.</span>
<span class="n">T_contra</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T_contra&#39;</span><span class="p">,</span> <span class="n">contravariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Ditto contravariant.</span>
<span class="c1"># Internal type variable used for Type[].</span>
<span class="n">CT_co</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;CT_co&#39;</span><span class="p">,</span> <span class="n">covariant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="nb">type</span><span class="p">)</span>

<span class="c1"># A useful type variable with constraints.  This represents string types.</span>
<span class="c1"># (This one *is* for export!)</span>
<span class="n">AnyStr</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;AnyStr&#39;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>


<span class="c1"># Various ABCs mimicking those in collections.abc.</span>
<span class="n">_alias</span> <span class="o">=</span> <span class="n">_SpecialGenericAlias</span>

<span class="n">Hashable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic.</span>
<span class="n">Awaitable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Awaitable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Coroutine</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Coroutine</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">AsyncIterable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">AsyncIterator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncIterator</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Iterable</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Iterator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Reversible</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Reversible</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Sized</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sized</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic.</span>
<span class="n">Container</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Container</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Collection</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Collection</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Callable</span> <span class="o">=</span> <span class="n">_CallableType</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Callable</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Callable</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to collections.abc.Callable.</span>

<span class="sd">    Callable[[int], str] signifies a function that takes a single</span>
<span class="sd">    parameter of type int and returns a str.</span>

<span class="sd">    The subscription syntax must always be used with exactly two</span>
<span class="sd">    values: the argument list and the return type.</span>
<span class="sd">    The argument list must be a list of types, a ParamSpec,</span>
<span class="sd">    Concatenate or ellipsis. The return type must be a single type.</span>

<span class="sd">    There is no syntax to indicate optional or keyword arguments;</span>
<span class="sd">    such function types are rarely used as callback types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="n">AbstractSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AbstractSet&#39;</span><span class="p">)</span>
<span class="n">MutableSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableSet</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># NOTE: Mapping is only covariant in the value type.</span>
<span class="n">Mapping</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">MutableMapping</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableMapping</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Sequence</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">MutableSequence</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MutableSequence</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ByteString</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ByteString</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Not generic</span>
<span class="c1"># Tuple accepts variable number of parameters.</span>
<span class="n">Tuple</span> <span class="o">=</span> <span class="n">_TupleType</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Tuple&#39;</span><span class="p">)</span>
<span class="n">Tuple</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to builtins.tuple.</span>

<span class="sd">    Tuple[X, Y] is the cross-product type of X and Y.</span>

<span class="sd">    Example: Tuple[T1, T2] is a tuple of two elements corresponding</span>
<span class="sd">    to type variables T1 and T2.  Tuple[int, float, str] is a tuple</span>
<span class="sd">    of an int, a float and a string.</span>

<span class="sd">    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].</span>
<span class="sd">    &quot;&quot;&quot;</span>
<span class="n">List</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;List&#39;</span><span class="p">)</span>
<span class="n">Deque</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Deque&#39;</span><span class="p">)</span>
<span class="n">Set</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Set&#39;</span><span class="p">)</span>
<span class="n">FrozenSet</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;FrozenSet&#39;</span><span class="p">)</span>
<span class="n">MappingView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">MappingView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">KeysView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">KeysView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ItemsView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ItemsView</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ValuesView</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">ValuesView</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ContextManager</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">contextlib</span><span class="o">.</span><span class="n">AbstractContextManager</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ContextManager&#39;</span><span class="p">)</span>
<span class="n">AsyncContextManager</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">contextlib</span><span class="o">.</span><span class="n">AbstractAsyncContextManager</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AsyncContextManager&#39;</span><span class="p">)</span>
<span class="n">Dict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Dict&#39;</span><span class="p">)</span>
<span class="n">DefaultDict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;DefaultDict&#39;</span><span class="p">)</span>
<span class="n">OrderedDict</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Counter</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ChainMap</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">ChainMap</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Generator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Generator</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">AsyncGenerator</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">AsyncGenerator</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Type</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inst</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Type&#39;</span><span class="p">)</span>
<span class="n">Type</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> \
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deprecated alias to builtins.type.</span>

<span class="sd">    builtins.type or typing.Type can be used to annotate class objects.</span>
<span class="sd">    For example, suppose we have the following classes::</span>

<span class="sd">        class User: ...  # Abstract base for User classes</span>
<span class="sd">        class BasicUser(User): ...</span>
<span class="sd">        class ProUser(User): ...</span>
<span class="sd">        class TeamUser(User): ...</span>

<span class="sd">    And a function that takes a class argument that&#39;s a subclass of</span>
<span class="sd">    User and returns an instance of the corresponding class::</span>

<span class="sd">        U = TypeVar(&#39;U&#39;, bound=User)</span>
<span class="sd">        def new_user(user_class: Type[U]) -&gt; U:</span>
<span class="sd">            user = user_class()</span>
<span class="sd">            # (Here we could write the user object to a database)</span>
<span class="sd">            return user</span>

<span class="sd">        joe = new_user(BasicUser)</span>

<span class="sd">    At this point the type checker knows that joe has type BasicUser.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SupportsInt</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __int__.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SupportsFloat</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __float__.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SupportsComplex</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __complex__.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__complex__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">complex</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SupportsBytes</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __bytes__.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__bytes__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SupportsIndex</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __index__.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__index__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SupportsAbs</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __abs__ that is covariant in its return type.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_co</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="nd">@runtime_checkable</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SupportsRound</span><span class="p">(</span><span class="n">Protocol</span><span class="p">[</span><span class="n">T_co</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An ABC with one abstract method __round__ that is covariant in its return type.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__round__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ndigits</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T_co</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_make_nmtuple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">defaults</span> <span class="o">=</span> <span class="p">()):</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">]</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;field </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> annotation must be a type&quot;</span><span class="p">)</span>
             <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">}</span>
    <span class="n">nm_tpl</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span>
                                    <span class="n">defaults</span><span class="o">=</span><span class="n">defaults</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">module</span><span class="p">)</span>
    <span class="n">nm_tpl</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">nm_tpl</span><span class="o">.</span><span class="fm">__new__</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">types</span>
    <span class="k">return</span> <span class="n">nm_tpl</span>


<span class="c1"># attributes prohibited to set in NamedTuple class syntax</span>
<span class="n">_prohibited</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;__new__&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">,</span> <span class="s1">&#39;__slots__&#39;</span><span class="p">,</span> <span class="s1">&#39;__getnewargs__&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;_fields&#39;</span><span class="p">,</span> <span class="s1">&#39;_field_defaults&#39;</span><span class="p">,</span>
                         <span class="s1">&#39;_make&#39;</span><span class="p">,</span> <span class="s1">&#39;_replace&#39;</span><span class="p">,</span> <span class="s1">&#39;_asdict&#39;</span><span class="p">,</span> <span class="s1">&#39;_source&#39;</span><span class="p">})</span>

<span class="n">_special</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">({</span><span class="s1">&#39;__module__&#39;</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;__annotations__&#39;</span><span class="p">})</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NamedTupleMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">typename</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">_NamedTuple</span> <span class="ow">in</span> <span class="n">bases</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_NamedTuple</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Generic</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s1">&#39;can only inherit from a NamedTuple type and Generic&#39;</span><span class="p">)</span>
        <span class="n">bases</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">tuple</span> <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="n">_NamedTuple</span> <span class="k">else</span> <span class="n">base</span> <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">)</span>
        <span class="n">types</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">default_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
                <span class="n">default_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">default_names</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Non-default namedtuple field </span><span class="si">{</span><span class="n">field_name</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;cannot follow default field&quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;s&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}</span><span class="s2"> &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">default_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">nm_tpl</span> <span class="o">=</span> <span class="n">_make_nmtuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span>
                               <span class="n">defaults</span><span class="o">=</span><span class="p">[</span><span class="n">ns</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">default_names</span><span class="p">],</span>
                               <span class="n">module</span><span class="o">=</span><span class="n">ns</span><span class="p">[</span><span class="s1">&#39;__module__&#39;</span><span class="p">])</span>
        <span class="n">nm_tpl</span><span class="o">.</span><span class="vm">__bases__</span> <span class="o">=</span> <span class="n">bases</span>
        <span class="k">if</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="n">class_getitem</span> <span class="o">=</span> <span class="n">Generic</span><span class="o">.</span><span class="n">__class_getitem__</span><span class="o">.</span><span class="vm">__func__</span>
            <span class="n">nm_tpl</span><span class="o">.</span><span class="n">__class_getitem__</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">class_getitem</span><span class="p">)</span>
        <span class="c1"># update from user namespace without overriding special namedtuple attributes</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">ns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_prohibited</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Cannot overwrite NamedTuple attribute &quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_special</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nm_tpl</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">nm_tpl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">ns</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">Generic</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="n">nm_tpl</span><span class="o">.</span><span class="n">__init_subclass__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nm_tpl</span>


<span class="k">def</span><span class="w"> </span><span class="nf">NamedTuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of namedtuple.</span>

<span class="sd">    Usage::</span>

<span class="sd">        class Employee(NamedTuple):</span>
<span class="sd">            name: str</span>
<span class="sd">            id: int</span>

<span class="sd">    This is equivalent to::</span>

<span class="sd">        Employee = collections.namedtuple(&#39;Employee&#39;, [&#39;name&#39;, &#39;id&#39;])</span>

<span class="sd">    The resulting class has an extra __annotations__ attribute, giving a</span>
<span class="sd">    dict that maps field names to types.  (The field names are also in</span>
<span class="sd">    the _fields attribute, which is part of the namedtuple API.)</span>
<span class="sd">    An alternative equivalent functional syntax is also accepted::</span>

<span class="sd">        Employee = NamedTuple(&#39;Employee&#39;, [(&#39;name&#39;, str), (&#39;id&#39;, int)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Either list of fields or keywords&quot;</span>
                        <span class="s2">&quot; can be provided to NamedTuple, not both&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_make_nmtuple</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">_caller</span><span class="p">())</span>

<span class="n">_NamedTuple</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">NamedTupleMeta</span><span class="p">,</span> <span class="s1">&#39;NamedTuple&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_namedtuple_mro_entries</span><span class="p">(</span><span class="n">bases</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">NamedTuple</span> <span class="ow">in</span> <span class="n">bases</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">_NamedTuple</span><span class="p">,)</span>

<span class="n">NamedTuple</span><span class="o">.</span><span class="n">__mro_entries__</span> <span class="o">=</span> <span class="n">_namedtuple_mro_entries</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_TypedDictMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new typed dict class object.</span>

<span class="sd">        This method is called when TypedDict is subclassed,</span>
<span class="sd">        or when TypedDict is instantiated. This way</span>
<span class="sd">        TypedDict supports all three syntax forms described in its docstring.</span>
<span class="sd">        Subclasses and instances of TypedDict return actual dictionaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_TypedDictMeta</span> <span class="ow">and</span> <span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">Generic</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;cannot inherit from both a TypedDict type &#39;</span>
                                <span class="s1">&#39;and a non-TypedDict base class&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Generic</span><span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">):</span>
            <span class="n">generic_base</span> <span class="o">=</span> <span class="p">(</span><span class="n">Generic</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">generic_base</span> <span class="o">=</span> <span class="p">()</span>

        <span class="n">tp_dict</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">_TypedDictMeta</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">generic_base</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="n">ns</span><span class="p">)</span>

        <span class="n">annotations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">own_annotations</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;TypedDict(&#39;Name&#39;, {f0: t0, f1: t1, ...}); each t must be a type&quot;</span>
        <span class="n">own_annotations</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">n</span><span class="p">:</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="n">tp_dict</span><span class="o">.</span><span class="vm">__module__</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">own_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">required_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">optional_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="n">bases</span><span class="p">:</span>
            <span class="n">annotations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">,</span> <span class="p">{}))</span>

            <span class="n">base_required</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__required_keys__&#39;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="n">required_keys</span> <span class="o">|=</span> <span class="n">base_required</span>
            <span class="n">optional_keys</span> <span class="o">-=</span> <span class="n">base_required</span>

            <span class="n">base_optional</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;__optional_keys__&#39;</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
            <span class="n">required_keys</span> <span class="o">-=</span> <span class="n">base_optional</span>
            <span class="n">optional_keys</span> <span class="o">|=</span> <span class="n">base_optional</span>

        <span class="n">annotations</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">own_annotations</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">annotation_key</span><span class="p">,</span> <span class="n">annotation_type</span> <span class="ow">in</span> <span class="n">own_annotations</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">annotation_origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">Annotated</span><span class="p">:</span>
                <span class="n">annotation_args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">annotation_args</span><span class="p">:</span>
                    <span class="n">annotation_type</span> <span class="o">=</span> <span class="n">annotation_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">annotation_origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation_type</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">Required</span><span class="p">:</span>
                <span class="n">is_required</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">annotation_origin</span> <span class="ow">is</span> <span class="n">NotRequired</span><span class="p">:</span>
                <span class="n">is_required</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">is_required</span> <span class="o">=</span> <span class="n">total</span>

            <span class="k">if</span> <span class="n">is_required</span><span class="p">:</span>
                <span class="n">required_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
                <span class="n">optional_keys</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">optional_keys</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>
                <span class="n">required_keys</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">annotation_key</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">required_keys</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">optional_keys</span><span class="p">),</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Required keys overlap with optional keys in </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">:&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">required_keys</span><span class="si">=}</span><span class="s2">, </span><span class="si">{</span><span class="n">optional_keys</span><span class="si">=}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">tp_dict</span><span class="o">.</span><span class="vm">__annotations__</span> <span class="o">=</span> <span class="n">annotations</span>
        <span class="n">tp_dict</span><span class="o">.</span><span class="n">__required_keys__</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">required_keys</span><span class="p">)</span>
        <span class="n">tp_dict</span><span class="o">.</span><span class="n">__optional_keys__</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">optional_keys</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tp_dict</span><span class="p">,</span> <span class="s1">&#39;__total__&#39;</span><span class="p">):</span>
            <span class="n">tp_dict</span><span class="o">.</span><span class="n">__total__</span> <span class="o">=</span> <span class="n">total</span>
        <span class="k">return</span> <span class="n">tp_dict</span>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="nb">dict</span>  <span class="c1"># static method</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__subclasscheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Typed dicts are only for static structural subtyping.</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;TypedDict does not support instance and class checks&#39;</span><span class="p">)</span>

    <span class="fm">__instancecheck__</span> <span class="o">=</span> <span class="fm">__subclasscheck__</span>


<span class="k">def</span><span class="w"> </span><span class="nf">TypedDict</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="n">fields</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple typed namespace. At runtime it is equivalent to a plain dict.</span>

<span class="sd">    TypedDict creates a dictionary type such that a type checker will expect all</span>
<span class="sd">    instances to have a certain set of keys, where each key is</span>
<span class="sd">    associated with a value of a consistent type. This expectation</span>
<span class="sd">    is not checked at runtime.</span>

<span class="sd">    Usage::</span>

<span class="sd">        &gt;&gt;&gt; class Point2D(TypedDict):</span>
<span class="sd">        ...     x: int</span>
<span class="sd">        ...     y: int</span>
<span class="sd">        ...     label: str</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; a: Point2D = {&#39;x&#39;: 1, &#39;y&#39;: 2, &#39;label&#39;: &#39;good&#39;}  # OK</span>
<span class="sd">        &gt;&gt;&gt; b: Point2D = {&#39;z&#39;: 3, &#39;label&#39;: &#39;bad&#39;}           # Fails type check</span>
<span class="sd">        &gt;&gt;&gt; Point2D(x=1, y=2, label=&#39;first&#39;) == dict(x=1, y=2, label=&#39;first&#39;)</span>
<span class="sd">        True</span>

<span class="sd">    The type info can be accessed via the Point2D.__annotations__ dict, and</span>
<span class="sd">    the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.</span>
<span class="sd">    TypedDict supports an additional equivalent form::</span>

<span class="sd">        Point2D = TypedDict(&#39;Point2D&#39;, {&#39;x&#39;: int, &#39;y&#39;: int, &#39;label&#39;: str})</span>

<span class="sd">    By default, all keys must be present in a TypedDict. It is possible</span>
<span class="sd">    to override this by specifying totality::</span>

<span class="sd">        class Point2D(TypedDict, total=False):</span>
<span class="sd">            x: int</span>
<span class="sd">            y: int</span>

<span class="sd">    This means that a Point2D TypedDict can have any of the keys omitted. A type</span>
<span class="sd">    checker is only expected to support a literal False or True as the value of</span>
<span class="sd">    the total argument. True is the default, and makes all items defined in the</span>
<span class="sd">    class body be required.</span>

<span class="sd">    The Required and NotRequired special forms can also be used to mark</span>
<span class="sd">    individual keys as being required or not required::</span>

<span class="sd">        class Point2D(TypedDict):</span>
<span class="sd">            x: int               # the &quot;x&quot; key must always be present (Required is the default)</span>
<span class="sd">            y: NotRequired[int]  # the &quot;y&quot; key can be omitted</span>

<span class="sd">    See PEP 655 for more details on Required and NotRequired.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="n">kwargs</span>
    <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;TypedDict takes either a dict or keyword arguments,&quot;</span>
                        <span class="s2">&quot; but not both&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;The kwargs-based syntax for TypedDict definitions is deprecated &quot;</span>
            <span class="s2">&quot;in Python 3.11, will be removed in Python 3.13, and may not be &quot;</span>
            <span class="s2">&quot;understood by third-party type checkers.&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">ns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;__annotations__&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fields</span><span class="p">)}</span>
    <span class="n">module</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">module</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Setting correct module is necessary to make typed dict classes pickleable.</span>
        <span class="n">ns</span><span class="p">[</span><span class="s1">&#39;__module__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">module</span>

    <span class="k">return</span> <span class="n">_TypedDictMeta</span><span class="p">(</span><span class="n">typename</span><span class="p">,</span> <span class="p">(),</span> <span class="n">ns</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">total</span><span class="p">)</span>

<span class="n">_TypedDict</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">_TypedDictMeta</span><span class="p">,</span> <span class="s1">&#39;TypedDict&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{})</span>
<span class="n">TypedDict</span><span class="o">.</span><span class="n">__mro_entries__</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bases</span><span class="p">:</span> <span class="p">(</span><span class="n">_TypedDict</span><span class="p">,)</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Required</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to mark a TypedDict key as required.</span>

<span class="sd">    This is mainly useful for total=False TypedDicts.</span>

<span class="sd">    For example::</span>

<span class="sd">        class Movie(TypedDict, total=False):</span>
<span class="sd">            title: Required[str]</span>
<span class="sd">            year: int</span>

<span class="sd">        m = Movie(</span>
<span class="sd">            title=&#39;The Matrix&#39;,  # typechecker error if key is omitted</span>
<span class="sd">            year=1999,</span>
<span class="sd">        )</span>

<span class="sd">    There is no runtime checking that a required key is actually provided</span>
<span class="sd">    when instantiating a related TypedDict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s1"> accepts only a single type.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>


<span class="nd">@_SpecialForm</span>
<span class="k">def</span><span class="w"> </span><span class="nf">NotRequired</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special typing construct to mark a TypedDict key as potentially missing.</span>

<span class="sd">    For example::</span>

<span class="sd">        class Movie(TypedDict):</span>
<span class="sd">            title: str</span>
<span class="sd">            year: NotRequired[int]</span>

<span class="sd">        m = Movie(</span>
<span class="sd">            title=&#39;The Matrix&#39;,  # typechecker error if key is omitted</span>
<span class="sd">            year=1999,</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">_type_check</span><span class="p">(</span><span class="n">parameters</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s1"> accepts only a single type.&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_GenericAlias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">(</span><span class="n">item</span><span class="p">,))</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NewType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;NewType creates simple unique types with almost zero runtime overhead.</span>

<span class="sd">    NewType(name, tp) is considered a subtype of tp</span>
<span class="sd">    by static type checkers. At runtime, NewType(name, tp) returns</span>
<span class="sd">    a dummy callable that simply returns its argument.</span>

<span class="sd">    Usage::</span>

<span class="sd">        UserId = NewType(&#39;UserId&#39;, int)</span>

<span class="sd">        def name_by_id(user_id: UserId) -&gt; str:</span>
<span class="sd">            ...</span>

<span class="sd">        UserId(&#39;user&#39;)          # Fails type check</span>

<span class="sd">        name_by_id(42)          # Fails type check</span>
<span class="sd">        name_by_id(UserId(42))  # OK</span>

<span class="sd">        num = UserId(5) + 1     # type: int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">_idfunc</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">rpartition</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__supertype__</span> <span class="o">=</span> <span class="n">tp</span>
        <span class="n">def_mod</span> <span class="o">=</span> <span class="n">_caller</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">def_mod</span> <span class="o">!=</span> <span class="s1">&#39;typing&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">def_mod</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__mro_entries__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span>
        <span class="c1"># We defined __mro_entries__ to get a better error message</span>
        <span class="c1"># if a user attempts to subclass a NewType instance. bpo-46170</span>
        <span class="n">superclass_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">Dummy</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                <span class="n">subclass_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot subclass an instance of NewType. Perhaps you were looking for: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;`</span><span class="si">{</span><span class="n">subclass_name</span><span class="si">}</span><span class="s2"> = NewType(</span><span class="si">{</span><span class="n">subclass_name</span><span class="si">!r}</span><span class="s2">, </span><span class="si">{</span><span class="n">superclass_name</span><span class="si">}</span><span class="s2">)`&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">Dummy</span><span class="p">,)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__qualname__</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Union</span><span class="p">[</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">]</span>


<span class="c1"># Python-version-specific alias (Python 2: unicode; Python 3: str)</span>
<span class="n">Text</span> <span class="o">=</span> <span class="nb">str</span>


<span class="c1"># Constant that&#39;s True when type checking, but False here.</span>
<span class="n">TYPE_CHECKING</span> <span class="o">=</span> <span class="kc">False</span>


<span class="k">class</span><span class="w"> </span><span class="nc">IO</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic base class for TextIO and BinaryIO.</span>

<span class="sd">    This is an abstract, generic version of the return of open().</span>

<span class="sd">    NOTE: This does not distinguish between the different possible</span>
<span class="sd">    classes (text vs. binary, read vs. write vs. read/write,</span>
<span class="sd">    append-only, unbuffered).  The TextIO and BinaryIO subclasses</span>
<span class="sd">    below capture the distinctions between text vs. binary, which is</span>
<span class="sd">    pervasive in the interface; however we currently do not offer a</span>
<span class="sd">    way to track the other distinctions in the type system.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fileno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isatty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">readable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyStr</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">readlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hint</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">]:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">whence</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">writable</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">AnyStr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">writelines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lines</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AnyStr</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;IO[AnyStr]&#39;</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BinaryIO</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of the return of open() in binary mode.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bytes</span><span class="p">,</span> <span class="nb">bytearray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;BinaryIO&#39;</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TextIO</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Typed version of the return of open() in text mode.&quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BinaryIO</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">encoding</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">errors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">line_buffering</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">newlines</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;TextIO&#39;</span><span class="p">:</span>
        <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_DeprecatedType</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;__dict__&quot;</span><span class="p">,</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">}</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> is deprecated, import directly &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;from typing instead. </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> will be removed &quot;</span>
                <span class="s2">&quot;in Python 3.12.&quot;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">io</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_DeprecatedType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper namespace for IO generic classes.&quot;&quot;&quot;</span>

    <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;IO&#39;</span><span class="p">,</span> <span class="s1">&#39;TextIO&#39;</span><span class="p">,</span> <span class="s1">&#39;BinaryIO&#39;</span><span class="p">]</span>
    <span class="n">IO</span> <span class="o">=</span> <span class="n">IO</span>
    <span class="n">TextIO</span> <span class="o">=</span> <span class="n">TextIO</span>
    <span class="n">BinaryIO</span> <span class="o">=</span> <span class="n">BinaryIO</span>


<span class="n">io</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.io&#39;</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">io</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">io</span>

<span class="n">Pattern</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">stdlib_re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Match</span> <span class="o">=</span> <span class="n">_alias</span><span class="p">(</span><span class="n">stdlib_re</span><span class="o">.</span><span class="n">Match</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">re</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">_DeprecatedType</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper namespace for re type aliases.&quot;&quot;&quot;</span>

    <span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Pattern&#39;</span><span class="p">,</span> <span class="s1">&#39;Match&#39;</span><span class="p">]</span>
    <span class="n">Pattern</span> <span class="o">=</span> <span class="n">Pattern</span>
    <span class="n">Match</span> <span class="o">=</span> <span class="n">Match</span>


<span class="n">re</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.re&#39;</span>
<span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">=</span> <span class="n">re</span>


<span class="k">def</span><span class="w"> </span><span class="nf">reveal_type</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ask a static type checker to reveal the inferred type of an expression.</span>

<span class="sd">    When a static type checker encounters a call to ``reveal_type()``,</span>
<span class="sd">    it will emit the inferred type of the argument::</span>

<span class="sd">        x: int = 1</span>
<span class="sd">        reveal_type(x)</span>

<span class="sd">    Running a static type checker (e.g., mypy) on this example</span>
<span class="sd">    will produce output similar to &#39;Revealed type is &quot;builtins.int&quot;&#39;.</span>

<span class="sd">    At runtime, the function prints the runtime type of the</span>
<span class="sd">    argument and returns the argument unchanged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Runtime type is </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dataclass_transform</span><span class="p">(</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">eq_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">order_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">kw_only_default</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">field_specifiers</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">T</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to mark an object as providing dataclass-like behaviour.</span>

<span class="sd">    The decorator can be applied to a function, class, or metaclass.</span>

<span class="sd">    Example usage with a decorator function::</span>

<span class="sd">        T = TypeVar(&quot;T&quot;)</span>

<span class="sd">        @dataclass_transform()</span>
<span class="sd">        def create_model(cls: type[T]) -&gt; type[T]:</span>
<span class="sd">            ...</span>
<span class="sd">            return cls</span>

<span class="sd">        @create_model</span>
<span class="sd">        class CustomerModel:</span>
<span class="sd">            id: int</span>
<span class="sd">            name: str</span>

<span class="sd">    On a base class::</span>

<span class="sd">        @dataclass_transform()</span>
<span class="sd">        class ModelBase: ...</span>

<span class="sd">        class CustomerModel(ModelBase):</span>
<span class="sd">            id: int</span>
<span class="sd">            name: str</span>

<span class="sd">    On a metaclass::</span>

<span class="sd">        @dataclass_transform()</span>
<span class="sd">        class ModelMeta(type): ...</span>

<span class="sd">        class ModelBase(metaclass=ModelMeta): ...</span>

<span class="sd">        class CustomerModel(ModelBase):</span>
<span class="sd">            id: int</span>
<span class="sd">            name: str</span>

<span class="sd">    The ``CustomerModel`` classes defined above will</span>
<span class="sd">    be treated by type checkers similarly to classes created with</span>
<span class="sd">    ``@dataclasses.dataclass``.</span>
<span class="sd">    For example, type checkers will assume these classes have</span>
<span class="sd">    ``__init__`` methods that accept ``id`` and ``name``.</span>

<span class="sd">    The arguments to this decorator can be used to customize this behavior:</span>
<span class="sd">    - ``eq_default`` indicates whether the ``eq`` parameter is assumed to be</span>
<span class="sd">        ``True`` or ``False`` if it is omitted by the caller.</span>
<span class="sd">    - ``order_default`` indicates whether the ``order`` parameter is</span>
<span class="sd">        assumed to be True or False if it is omitted by the caller.</span>
<span class="sd">    - ``kw_only_default`` indicates whether the ``kw_only`` parameter is</span>
<span class="sd">        assumed to be True or False if it is omitted by the caller.</span>
<span class="sd">    - ``field_specifiers`` specifies a static list of supported classes</span>
<span class="sd">        or functions that describe fields, similar to ``dataclasses.field()``.</span>
<span class="sd">    - Arbitrary other keyword arguments are accepted in order to allow for</span>
<span class="sd">        possible future extensions.</span>

<span class="sd">    At runtime, this decorator records its arguments in the</span>
<span class="sd">    ``__dataclass_transform__`` attribute on the decorated object.</span>
<span class="sd">    It has no other runtime effect.</span>

<span class="sd">    See PEP 681 for more details.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">decorator</span><span class="p">(</span><span class="n">cls_or_fn</span><span class="p">):</span>
        <span class="n">cls_or_fn</span><span class="o">.</span><span class="n">__dataclass_transform__</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;eq_default&quot;</span><span class="p">:</span> <span class="n">eq_default</span><span class="p">,</span>
            <span class="s2">&quot;order_default&quot;</span><span class="p">:</span> <span class="n">order_default</span><span class="p">,</span>
            <span class="s2">&quot;kw_only_default&quot;</span><span class="p">:</span> <span class="n">kw_only_default</span><span class="p">,</span>
            <span class="s2">&quot;field_specifiers&quot;</span><span class="p">:</span> <span class="n">field_specifiers</span><span class="p">,</span>
            <span class="s2">&quot;kwargs&quot;</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cls_or_fn</span>
    <span class="k">return</span> <span class="n">decorator</span>
</pre></div>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=a63be7f4"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    </body>
</html>