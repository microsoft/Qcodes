"""Sphinx extension for auto-documenting decorator-style parameters.

Author: Victor Neg√Ærneac, vnegirneac@qblox.com

.. warning::

    The functions in this modules are not intended to be used directly.
    Intended to be called by sphinx only.

A sphinx extension that patches several parts of sphinx and autodoc in order
to allow nice auto-documentation of parameters added with the
:func:`qcodes.instrument.base.add_parameter` decorator function, i.e.,
:func:`@add_parameter <qcodes.instrument.base.add_parameter>`
[NB do not confuse with the method
:meth:`qcodes.instrument.base.InstrumentBase.add_parameter`].

The implementation is hacky but attempts to be minimally intrusive and somewhat
resilient to future changes in the patched methods.

Usage
~~~~~

In the :code:`conf.py` add this extension to sphinx:

.. code-block:: python

    # ...

    extensions = [
        # ...
        "qcodes.sphinx_extensions.add_parameter",
    ]

    # Optionally you can disable the modifications done to the docstring

    qcodes_parameters_spec_in_docstring = True # default value
    '''
    Convert the signature of the decorated method to the docstring of parameter.
    '''

    qcodes_parameters_spec_with_links = True # default value
    '''
    Create a reference with a hyperlink to the parameter class.
    Option exists in case this functionality creates broken links.
    '''
    qcodes_parameters_force_documenting = True # default value
    '''
    In your sphinx configuration you are likely not documenting private methods,
    but the `@add_parameter` decorates a private method. This option forces
    these methods to be documented.
    '''

In your :code:`.rst` files use autodoc directives as usual.

If you need to manually place the documentation of a specific parameter in some part
of your docs you must point to the name of the method that was decorated with
`@add_parameter`. E.g.,

.. code-block:: rst

    .. automethod:: qcodes.instrument_drivers.decorator_style.MyInstrumentDriver._parameter_freq

Which should produce an output similar to:

    .. automethod:: qcodes.instrument_drivers.decorator_style.MyInstrumentDriver._parameter_freq
        :noindex:

---

The qcodes parameters of an Instrument added with
:func:`@add_parameter <qcodes.instrument.base.add_parameter>`
can be referenced in the :code:`.rst` files with the :code:`:obj:` or :code:`:meth:` roles,
assuming the class is documented in the API reference of your python project.

.. code-block:: rst

    A reference to :obj:`qcodes.instrument_drivers.decorator_style.MyInstrumentDriver.freq` or
    :meth:`~qcodes.instrument_drivers.decorator_style.MyInstrumentDriver.freq`.

Will be displayed as "A reference to
:obj:`qcodes.instrument_drivers.decorator_style.MyInstrumentDriver.freq` or
:meth:`~qcodes.instrument_drivers.decorator_style.MyInstrumentDriver.freq` ."

Module members
~~~~~~~~~~~~~~
"""  # pylint: disable=line-too-long
import inspect
from sphinx.ext import autodoc
from sphinx.domains import python as sphinx_domains_python

from qcodes.instrument.base import _ADD_PARAMETER_ATTR_NAME, _DECORATED_METHOD_PREFIX

# ######################################################################################
# Rename the special method and prefix it with "parameter " in docs output
# ######################################################################################

def format_name(self) -> str:
    """Removes :code:`"_parameter_"` prefix from method name in sphinx output.

    Only the QCoDeS parameter name will be displayed in the docs.

    Patches: :meth:`!sphinx.ext.autodoc.MethodDocumenter.format_name` .
    """
    if hasattr(self.object, _ADD_PARAMETER_ATTR_NAME):
        return ".".join(
            self.objpath[:-1] + [self.objpath[-1][len(_DECORATED_METHOD_PREFIX) :]]
        )
    return ".".join(self.objpath) or self.modname


original_add_directive_header = autodoc.MethodDocumenter.add_directive_header


def add_directive_header(self, sig: str) -> None:
    """
    Adds the :code:`:parameter:` option to the :code:`.. py:meth::` directive
    generated by autodoc. This option is then translated to the actual
    :code:`parameter ` prefix displayed in docs inside the
    :func:`~qcodes.sphinx_extensions.add_parameter.get_signature_prefix` .

    Patches: :meth:`!sphinx.ext.autodoc.MethodDocumenter.add_directive_header` .
    """
    original_add_directive_header(self, sig)
    if self.object_name.startswith(_DECORATED_METHOD_PREFIX):
        sourcename = self.get_sourcename()
        self.add_line("   :parameter:", sourcename)


original_get_signature_prefix = sphinx_domains_python.PyMethod.get_signature_prefix


def get_signature_prefix(self, sig: str) -> str:
    """
    Detects the :code:`:parameter:` option added by
    :func:`~qcodes.sphinx_extensions.add_parameter.add_directive_header` and appends
    the parameter's signature prefix with :code:`"parameter "`.

    Patches: :meth:`!sphinx.domains.python.PyMethod.get_signature_prefix` .
    """
    prefix_str = original_get_signature_prefix(self, sig)
    if "parameter" in self.options:
        prefix_str += "parameter "

    return prefix_str


# ######################################################################################
# Move parameter instantiation specification to the docstring and remove from signature
# ######################################################################################

def add_parameter_spec_to_docstring(app, what, name, obj, options, lines):
    """
    Processes, and appends to the docstring, the signature of the methods decorated with
    :func:`@add_parameter <qcodes.instrument.base.add_parameter>` .

    Intercepts :code:`"autodoc-process-docstring"` .
    """
    # name is e.g. `"my_module._parameter_time"
    modify_docstring = app.config["qcodes_parameters_spec_in_docstring"]
    add_links = "" if app.config["qcodes_parameters_spec_with_links"] else "!"
    if modify_docstring and hasattr(obj, _ADD_PARAMETER_ATTR_NAME):
        lines += [
            "",
            ".. rubric:: Arguments passed to "
            f":meth:`{add_links}qcodes.instrument.base.InstrumentBase.add_parameter`:",
            "",
        ]
        for kw_name, par_obj in inspect.signature(obj).parameters.items():
            if kw_name != "self":
                if kw_name == "parameter_class":
                    # create link to the parameter class
                    mod = par_obj.default.__module__
                    class_name = par_obj.default.__name__
                    value = f":class:`{add_links}{mod}.{class_name}`"
                else:
                    value = f"*{par_obj.default!r}*"

                if add_links == "" and kw_name == "vals":
                    kw_name = ":mod:`vals <qcodes.utils.validators>`"
                else:
                    kw_name = f"**{kw_name}**"
                lines.append(f"- {kw_name} = {value}")
        lines += [""]

    return lines


def clear_parameter_method_signature(
    app, what, name, obj, options, signature, return_annotation
):
    """
    Intercepts :code:`"autodoc-skip-member"` and forces documenting the methods that
    have been decorated with
    :func:`@add_parameter <qcodes.instrument.base.add_parameter>` .
    """
    modify_dosctring = app.config["qcodes_parameters_spec_in_docstring"]
    if modify_dosctring and hasattr(obj, _ADD_PARAMETER_ATTR_NAME):
        signature = "()"
    return (signature, return_annotation)

# ######################################################################################
# Setup sphinx extension
# ######################################################################################

def dont_skip_qcodes_params(app, what, name, obj, skip, options) -> bool:
    """
    Intercepts :code:`"autodoc-process-signature"` and sets the signature to
    :code:`"()"`.
    """
    if hasattr(obj, _ADD_PARAMETER_ATTR_NAME):
        return not app.config["qcodes_parameters_force_documenting"]
    return skip

def setup(app):
    """Called by sphinx to setup the extension."""
    app.setup_extension('sphinx.ext.autodoc')  # Require autodoc extension

    # Register the extension configuration parameters
    app.add_config_value(
        name="qcodes_parameters_spec_in_docstring",
        default=True,
        rebuild="html",
        types=[bool]
    )
    app.add_config_value(
        name="qcodes_parameters_spec_with_links",
        default=True,
        rebuild="html",
        types=[bool]
    )
    app.add_config_value(
        name="qcodes_parameters_force_documenting",
        default=True,
        rebuild="html",
        types=[bool]
    )
    # we can't have a method in the class with the same name as the desired
    # parameter, therefore we patch the method name displayed in the sphinx docs
    # monkey patching `MethodDocumenter`
    # e.g. `_parameter_time` -> `time` when displayed in the docs
    autodoc.MethodDocumenter.format_name = format_name

    # Patch several parts of autodoc and sphinx so that we have a nice
    # "parameter " prefix added in the docs output, similar to, e.g., "classmethod ".
    autodoc.MethodDocumenter.add_directive_header = add_directive_header
    sphinx_domains_python.PyMethod.option_spec.update(
        {"parameter": sphinx_domains_python.PyMethod.option_spec["classmethod"]}
    )
    sphinx_domains_python.PyMethod.get_signature_prefix = get_signature_prefix

    # enforce always documenting the decorated private methods whose name is
    # prefixed with _ADD_PARAMETER_ATTR_NAME
    app.connect("autodoc-skip-member", dont_skip_qcodes_params)
    # convert the signature of the decorated methods to a nicely formatted list in the
    # docstring
    app.connect("autodoc-process-docstring", add_parameter_spec_to_docstring)
    app.connect("autodoc-process-signature", clear_parameter_method_signature)

    return {
        'version': '0.1',
        'parallel_read_safe': True,  # Not tested, should not be an issue
        'parallel_write_safe': True,  # Not tested, should not be an issue
    }
