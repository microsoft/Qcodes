# NOTE SR86x.py is generated from a template file (SR86x.jinja).
# To make changes, edit the template file and regenerate.
# Any changes to SR86x.py will be overwritten.
from __future__ import annotations

import logging
from typing import TYPE_CHECKING, ClassVar

from qcodes.instrument import (
    ChannelList,
    ChannelTuple,
    VisaInstrument,
    VisaInstrumentKWArgs,
)
from qcodes.validators import ComplexNumbers, Enum, Ints, Numbers

from ._SR86x_modules import SR86xBuffer, SR86xDataChannel

if TYPE_CHECKING:
    from typing_extensions import Unpack

    from qcodes.parameters import Parameter

log = logging.getLogger(__name__)


class SR86x(VisaInstrument):
    """
    Base class for Stanford SR86x Lock-in Amplifier drivers. This class should not
    be instantiated directly instead one of the model specific sub classes should be used.
    """

    _VOLT_TO_N: ClassVar[dict[int | float, int]] = {
        1: 0,
        500e-3: 1,
        200e-3: 2,
        100e-3: 3,
        50e-3: 4,
        20e-3: 5,
        10e-3: 6,
        5e-3: 7,
        2e-3: 8,
        1e-3: 9,
        500e-6: 10,
        200e-6: 11,
        100e-6: 12,
        50e-6: 13,
        20e-6: 14,
        10e-6: 15,
        5e-6: 16,
        2e-6: 17,
        1e-6: 18,
        500e-9: 19,
        200e-9: 20,
        100e-9: 21,
        50e-9: 22,
        20e-9: 23,
        10e-9: 24,
        5e-9: 25,
        2e-9: 26,
        1e-9: 27,
    }
    _N_TO_VOLT: ClassVar[dict[int, int | float]] = {v: k for k, v in _VOLT_TO_N.items()}

    _CURR_TO_N: ClassVar[dict[float, int]] = {
        1e-6: 0,
        500e-9: 1,
        200e-9: 2,
        100e-9: 3,
        50e-9: 4,
        20e-9: 5,
        10e-9: 6,
        5e-9: 7,
        2e-9: 8,
        1e-9: 9,
        500e-12: 10,
        200e-12: 11,
        100e-12: 12,
        50e-12: 13,
        20e-12: 14,
        10e-12: 15,
        5e-12: 16,
        2e-12: 17,
        1e-12: 18,
        500e-15: 19,
        200e-15: 20,
        100e-15: 21,
        50e-15: 22,
        20e-15: 23,
        10e-15: 24,
        5e-15: 25,
        2e-15: 26,
        1e-15: 27,
    }
    _N_TO_CURR: ClassVar[dict[int, float]] = {v: k for k, v in _CURR_TO_N.items()}

    _VOLT_ENUM = Enum(*_VOLT_TO_N.keys())
    _CURR_ENUM = Enum(*_CURR_TO_N.keys())

    _INPUT_SIGNAL_TO_N: ClassVar[dict[str, int]] = {
        "voltage": 0,
        "current": 1,
    }
    _N_TO_INPUT_SIGNAL: ClassVar[dict[int, str]] = {
        v: k for k, v in _INPUT_SIGNAL_TO_N.items()
    }

    PARAMETER_NAMES: ClassVar[dict[str, str]] = {
        "X": "0",  # X output, 'X'
        "Y": "1",  # Y output, 'Y'
        "R": "2",  # R output, 'R'
        "P": "3",  # theta output, 'THeta'
        "aux_in1": "4",  # Aux In 1, 'IN1'
        "aux_in2": "5",  # Aux In 2, 'IN2'
        "aux_in3": "6",  # Aux In 3, 'IN3'
        "aux_in4": "7",  # Aux In 4, 'IN4'
        "Xnoise": "8",  # X noise, 'XNOise'
        "Ynoise": "9",  # Y noise, 'YNOise'
        "aux_out1": "10",  # Aux Out 1, 'OUT1'
        "aux_out2": "11",  # Aux Out 2, 'OUT2'
        "phase": "12",  # Reference Phase, 'PHAse'
        "amplitude": "13",  # Sine Out Amplitude, 'SAMp'
        "sine_outdc": "14",  # DC Level, 'LEVel'
        "frequency": "15",  # Int. Ref. Frequency, 'FInt'
        "frequency_ext": "16",  # Ext. Ref. Frequency, 'FExt'
    }

    _N_DATA_CHANNELS = 4

    default_terminator = "\n"

    def __init__(
        self,
        name: str,
        address: str,
        max_frequency: float,
        reset: bool = False,
        **kwargs: Unpack[VisaInstrumentKWArgs],
    ):
        super().__init__(name, address, **kwargs)
        self._max_frequency = max_frequency
        # Reference commands
        self.frequency: Parameter = self.add_parameter(
            name="frequency",
            label="Frequency",
            unit="Hz",
            get_cmd="FREQ?",
            set_cmd="FREQ {}",
            get_parser=float,
            vals=Numbers(min_value=1e-3, max_value=self._max_frequency),
        )
        """Parameter frequency"""
        self.sine_outdc: Parameter = self.add_parameter(
            name="sine_outdc",
            label="Sine out dc level",
            unit="V",
            get_cmd="SOFF?",
            set_cmd="SOFF {}",
            get_parser=float,
            vals=Numbers(min_value=-5, max_value=5),
        )
        """Parameter sine_outdc"""
        self.amplitude: Parameter = self.add_parameter(
            name="amplitude",
            label="Amplitude",
            unit="V",
            get_cmd="SLVL?",
            set_cmd="SLVL {}",
            get_parser=float,
            vals=Numbers(min_value=0, max_value=2),
        )
        """Parameter amplitude"""
        self.harmonic: Parameter = self.add_parameter(
            name="harmonic",
            label="Harmonic",
            get_cmd="HARM?",
            get_parser=int,
            set_cmd="HARM {:d}",
            vals=Ints(min_value=1, max_value=99),
        )
        """Parameter harmonic"""
        self.phase: Parameter = self.add_parameter(
            name="phase",
            label="Phase",
            unit="deg",
            get_cmd="PHAS?",
            set_cmd="PHAS {}",
            get_parser=float,
            vals=Numbers(min_value=-3.6e5, max_value=3.6e5),
        )
        """Parameter phase"""
        # Signal commands
        self.sensitivity: Parameter = self.add_parameter(
            name="sensitivity",
            label="Sensitivity",
            get_cmd="SCAL?",
            set_cmd="SCAL {:d}",
            get_parser=self._get_sensitivity,
            set_parser=self._set_sensitivity,
        )
        """Parameter sensitivity"""
        self.filter_slope: Parameter = self.add_parameter(
            name="filter_slope",
            label="Filter slope",
            unit="dB/oct",
            get_cmd="OFSL?",
            set_cmd="OFSL {}",
            val_mapping={6: 0, 12: 1, 18: 2, 24: 3},
        )
        """Parameter filter_slope"""
        self.sync_filter: Parameter = self.add_parameter(
            name="sync_filter",
            label="Sync filter",
            get_cmd="SYNC?",
            set_cmd="SYNC {}",
            val_mapping={"OFF": 0, "ON": 1},
        )
        """Parameter sync_filter"""
        self.noise_bandwidth: Parameter = self.add_parameter(
            name="noise_bandwidth",
            label="Noise bandwidth",
            unit="Hz",
            get_cmd="ENBW?",
            get_parser=float,
        )
        """Parameter noise_bandwidth"""
        self.signal_strength: Parameter = self.add_parameter(
            name="signal_strength",
            label="Signal strength indicator",
            get_cmd="ILVL?",
            get_parser=int,
        )
        """Parameter signal_strength"""
        self.signal_input: Parameter = self.add_parameter(
            name="signal_input",
            label="Signal input",
            get_cmd="IVMD?",
            get_parser=self._get_input_config,
            set_cmd="IVMD {}",
            set_parser=self._set_input_config,
            vals=Enum(*self._INPUT_SIGNAL_TO_N.keys()),
        )
        """Parameter signal_input"""
        self.input_range: Parameter = self.add_parameter(
            name="input_range",
            label="Input range",
            unit="V",
            get_cmd="IRNG?",
            set_cmd="IRNG {}",
            val_mapping={1: 0, 300e-3: 1, 100e-3: 2, 30e-3: 3, 10e-3: 4},
        )
        """Parameter input_range"""
        self.input_config: Parameter = self.add_parameter(
            name="input_config",
            label="Input configuration",
            get_cmd="ISRC?",
            set_cmd="ISRC {}",
            val_mapping={"a": 0, "a-b": 1},
        )
        """Parameter input_config"""
        self.input_shield: Parameter = self.add_parameter(
            name="input_shield",
            label="Input shield",
            get_cmd="IGND?",
            set_cmd="IGND {}",
            val_mapping={"float": 0, "ground": 1},
        )
        """Parameter input_shield"""
        self.input_gain: Parameter = self.add_parameter(
            name="input_gain",
            label="Input gain",
            unit="ohm",
            get_cmd="ICUR?",
            set_cmd="ICUR {}",
            val_mapping={1e6: 0, 100e6: 1},
        )
        """Parameter input_gain"""
        self.adv_filter: Parameter = self.add_parameter(
            name="adv_filter",
            label="Advanced filter",
            get_cmd="ADVFILT?",
            set_cmd="ADVFILT {}",
            val_mapping={"OFF": 0, "ON": 1},
        )
        """Parameter adv_filter"""
        self.input_coupling: Parameter = self.add_parameter(
            name="input_coupling",
            label="Input coupling",
            get_cmd="ICPL?",
            set_cmd="ICPL {}",
            val_mapping={"ac": 0, "dc": 1},
        )
        """Parameter input_coupling"""
        self.time_constant: Parameter = self.add_parameter(
            name="time_constant",
            label="Time constant",
            unit="s",
            get_cmd="OFLT?",
            set_cmd="OFLT {}",
            val_mapping={
                1e-6: 0,
                3e-6: 1,
                10e-6: 2,
                30e-6: 3,
                100e-6: 4,
                300e-6: 5,
                1e-3: 6,
                3e-3: 7,
                10e-3: 8,
                30e-3: 9,
                100e-3: 10,
                300e-3: 11,
                1: 12,
                3: 13,
                10: 14,
                30: 15,
                100: 16,
                300: 17,
                1e3: 18,
                3e3: 19,
                10e3: 20,
                30e3: 21,
            },
        )
        """Parameter time_constant"""

        self.external_reference_trigger: Parameter = self.add_parameter(
            name="external_reference_trigger",
            label="External reference trigger mode",
            get_cmd="RTRG?",
            set_cmd="RTRG {}",
            val_mapping={
                "SIN": 0,
                "POS": 1,
                "POSTTL": 1,
                "NEG": 2,
                "NEGTTL": 2,
            },
            docstring="The triggering mode for synchronization of the "
            "internal reference signal with the externally provided "
            "one",
        )
        """The triggering mode for synchronization of the internal reference signal with the externally provided one"""

        self.reference_source: Parameter = self.add_parameter(
            name="reference_source",
            label="Reference source",
            get_cmd="RSRC?",
            set_cmd="RSRC {}",
            val_mapping={"INT": 0, "EXT": 1, "DUAL": 2, "CHOP": 3},
            docstring="The source of the reference signal",
        )
        """The source of the reference signal"""

        self.external_reference_trigger_input_resistance: Parameter = (
            self.add_parameter(
                name="external_reference_trigger_input_resistance",
                label="External reference trigger input resistance",
                get_cmd="REFZ?",
                set_cmd="REFZ {}",
                val_mapping={
                    "50": 0,
                    "50OHMS": 0,
                    0: 0,
                    "1M": 1,
                    "1MEG": 1,
                    1: 1,
                },
                docstring="Input resistance of the input for the external "
                "reference signal",
            )
        )
        """Input resistance of the input for the external reference signal"""

        # Auto functions
        self.add_function("auto_range", call_cmd="ARNG")
        self.add_function("auto_scale", call_cmd="ASCL")
        self.add_function("auto_phase", call_cmd="APHS")

        # Data transfer
        # first 4 parameters from a list of 16 below.
        self.X: Parameter = self.add_parameter(
            "X",
            label="In-phase Magnitude",
            get_cmd="OUTP? 0",
            get_parser=float,
            unit="V",
        )
        """Parameter X"""
        self.Y: Parameter = self.add_parameter(
            "Y",
            label="Out-phase Magnitude",
            get_cmd="OUTP? 1",
            get_parser=float,
            unit="V",
        )
        """Parameter Y"""
        self.R: Parameter = self.add_parameter(
            "R", label="Magnitude", get_cmd="OUTP? 2", get_parser=float, unit="V"
        )
        """Parameter R"""
        self.P: Parameter = self.add_parameter(
            "P", label="Phase", get_cmd="OUTP? 3", get_parser=float, unit="deg"
        )
        """Parameter P"""

        self.complex_voltage: Parameter = self.add_parameter(
            "complex_voltage",
            label="Voltage",
            get_cmd=self._get_complex_voltage,
            unit="V",
            vals=ComplexNumbers(),
        )
        """Parameter complex_voltage"""

        # CH1/CH2 Output Commands
        self.X_offset: Parameter = self.add_parameter(
            "X_offset",
            label="X offset ",
            unit="%",
            get_cmd="COFP? 0",
            set_cmd="COFP 0, {}",
            get_parser=float,
            vals=Numbers(min_value=-999.99, max_value=999.99),
        )
        """Parameter X_offset"""
        self.Y_offset: Parameter = self.add_parameter(
            "Y_offset",
            label="Y offset",
            unit="%",
            get_cmd="COFP? 1",
            set_cmd="COFP 1, {}",
            get_parser=float,
            vals=Numbers(min_value=-999.99, max_value=999.99),
        )
        """Parameter Y_offset"""
        self.R_offset: Parameter = self.add_parameter(
            "R_offset",
            label="R offset",
            unit="%",
            get_cmd="COFP? 2",
            set_cmd="COFP 2, {}",
            get_parser=float,
            vals=Numbers(min_value=-999.99, max_value=999.99),
        )
        """Parameter R_offset"""
        self.X_expand: Parameter = self.add_parameter(
            "X_expand",
            label="X expand multiplier",
            get_cmd="CEXP? 0",
            set_cmd="CEXP 0, {}",
            val_mapping={"OFF": "0", "X10": "1", "X100": "2"},
        )
        """Parameter X_expand"""
        self.Y_expand: Parameter = self.add_parameter(
            "Y_expand",
            label="Y expand multiplier",
            get_cmd="CEXP? 1",
            set_cmd="CEXP 1, {}",
            val_mapping={"OFF": 0, "X10": 1, "X100": 2},
        )
        """Parameter Y_expand"""
        self.R_expand: Parameter = self.add_parameter(
            "R_expand",
            label="R expand multiplier",
            get_cmd="CEXP? 2",
            set_cmd="CEXP 2, {}",
            val_mapping={"OFF": 0, "X10": 1, "X100": 2},
        )
        """Parameter R_expand"""

        # Aux input/output
        {% for i in [0, 1, 2, 3] %}
        self.aux_in{{i}} = self.add_parameter(
            "aux_in{{i}}",
            label="Aux input {{i}}",
            get_cmd="OAUX? {{i}}",
            get_parser=float,
            unit="V",
        )
        self.aux_out{{i}} = self.add_parameter(
            "aux_out{{i}}",
            label="Aux output {{i}}",
            get_cmd="AUXV? {{i}}",
            get_parser=float,
            set_cmd="AUXV {{i}}, {}",
            unit="V",
        )
        {% endfor %}

        # Data channels:
        # 'DAT1' (green), 'DAT2' (blue), 'DAT3' (yellow), 'DAT4' (orange)
        data_channels = ChannelList(
            self, "data_channels", SR86xDataChannel, snapshotable=False
        )
        {% for num, color in [(0, "green"), (1, "blue"), (2, "yellow"), (3, "orange")] %}

        data_channel = SR86xDataChannel(self, "data_channel_{{ num + 1 }}", "{{ num }}", "DAT{{ num + 1 }}", "{{ color }}")

        data_channels.append(data_channel)
        self.data_channel_{{ num + 1 }} = self.add_submodule("data_channel_{{ num + 1 }}", data_channel)
        {% endfor %}

        self.data_channels: ChannelTuple[SR86xDataChannel] = self.add_submodule(
            "data_channels", data_channels.to_channel_tuple()
        )
        """Interface for the SR86x data channels"""

        # Interface
        self.add_function("reset", call_cmd="*RST")

        self.add_function("disable_front_panel", call_cmd="OVRM 0")
        self.add_function("enable_front_panel", call_cmd="OVRM 1")

        buffer = SR86xBuffer(self, f"{self.name}_buffer")
        self.buffer: SR86xBuffer = self.add_submodule("buffer", buffer)
        """Interface for the SR86x buffer"""

        self.input_config()
        self.connect_message()

    def _set_units(self, unit: str) -> None:
        for param in [self.X, self.Y, self.R, self.sensitivity]:
            param.unit = unit

    def _get_complex_voltage(self) -> complex:
        x, y = self.get_values("X", "Y")
        return x + 1.0j * y

    def _get_input_config(self, s: int) -> str:
        mode = self._N_TO_INPUT_SIGNAL[int(s)]

        if mode == "voltage":
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units("V")
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units("A")

        return mode

    def _set_input_config(self, s: str) -> int:
        if s == "voltage":
            self.sensitivity.vals = self._VOLT_ENUM
            self._set_units("V")
        else:
            self.sensitivity.vals = self._CURR_ENUM
            self._set_units("A")

        return self._INPUT_SIGNAL_TO_N[s]

    def _get_sensitivity(self, s: int) -> float:
        if self.signal_input() == "voltage":
            return self._N_TO_VOLT[int(s)]
        else:
            return self._N_TO_CURR[int(s)]

    def _set_sensitivity(self, s: float) -> int:
        if self.signal_input() == "voltage":
            return self._VOLT_TO_N[s]
        else:
            return self._CURR_TO_N[s]

    def get_values(self, *parameter_names: str) -> tuple[float, ...]:
        """
        Get values of 2 or 3 parameters that are measured by the lock-in
        amplifier. These values are guaranteed to come from the same
        measurement cycle as opposed to getting values of parameters one by
        one (for example, by calling `sr.X()`, and then `sr.Y()`.

        Args:
            *parameter_names: 2 or 3 names of parameters for which the values
                are requested; valid names can be found in `PARAMETER_NAMES`
                attribute of the driver class

        Returns:
            a tuple of 2 or 3 floating point values

        """
        if not 2 <= len(parameter_names) <= 3:
            raise KeyError(
                "It is only possible to request values of 2 or 3 parameters at a time."
            )

        for name in parameter_names:
            if name not in self.PARAMETER_NAMES:
                raise KeyError(
                    f"{name} is not a valid parameter name. Refer "
                    f"to `PARAMETER_NAMES` for a list of valid "
                    f"parameter names"
                )

        p_ids = [self.PARAMETER_NAMES[name] for name in parameter_names]
        output = self.ask(f"SNAP? {','.join(p_ids)}")
        return tuple(float(val) for val in output.split(","))

    def get_data_channels_values(self) -> tuple[float, ...]:
        """
        Queries the current values of the data channels

        Returns:
            tuple of 4 values of the data channels

        """
        output = self.ask("SNAPD?")
        return tuple(float(val) for val in output.split(","))

    def get_data_channels_parameters(
        self, query_instrument: bool = True
    ) -> tuple[str, ...]:
        """
        Convenience method to query a list of parameters which the data
        channels are currently assigned to.

        Args:
            query_instrument: If set to False, the internally cashed names of
                the parameters will be returned; if True, then the names will
                be queried through the instrument

        Returns:
            a tuple of 4 strings of parameter names

        """
        if query_instrument:
            method_name = "get"
        else:
            method_name = "get_latest"

        return tuple(
            getattr(getattr(self.data_channels[i], "assigned_parameter"), method_name)()
            for i in range(self._N_DATA_CHANNELS)
        )

    def get_data_channels_dict(self, requery_names: bool = False) -> dict[str, float]:
        """
        Returns a dictionary where the keys are parameter names currently
        assigned to the data channels, and values are the values of those
        parameters.

        Args:
            requery_names: if False, the currently assigned parameter names
                will not be queries from the instrument in order to save time
                on communication, in this case the cached assigned parameter
                names will be used for the keys of the dicitonary; if True,
                the assigned parameter names will be queried from the
                instrument

        Returns:
            a dictionary where keys are names of parameters assigned to the
            data channels, and values are the values of those parameters

        """
        parameter_names = self.get_data_channels_parameters(requery_names)
        parameter_values = self.get_data_channels_values()
        return dict(zip(parameter_names, parameter_values))
